{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#moose-molecular-optical-emission-simulation-for-python","title":"Moose: Molecular Optical Emission Simulation for python","text":"<p>Welcome to <code>Moose</code>, a python package for simulating optical emission spectra for diatomic molecules.</p> <p><code>Moose</code> was born out of a need to fit rotational and vibrational temperatures for a large set of data.</p> <p>For this it uses line-by-line databases, assuming a Boltzmann distribution for rotational and/or vibrational temperatures.</p> <p>On top of that <code>Moose</code> is intended to be minimal: it provides you some basic tools to do just that, simulate some spectra.</p> <p>It is up to you to read and sanitize experimental data, that you would like to fit based on these simulations, for instance.</p> <p>Put differently, <code>Moose</code> is aimed at helping you: you can integrate and adapt it to your workflow, rather than the reverse.</p> <p>Additionally, it has only a few, common dependencies (<code>numpy</code>, <code>scipy</code>, <code>pandas</code>) by default.</p> <p>To get a better grasp of how it works under the hood, see the code reference</p>"},{"location":"#massiveoes","title":"MassiveOES","text":"<p>The code that turned into <code>Moose</code>, was intended as a wrapper for MassiveOES, to parallelize it with Dask.</p> <p>However, the basic desired functionality was easier to implement separately in a stateless manner, rather than probably reworking the entire library.</p> <p>The goal is not to provide the same functionality as <code>MassiveOES</code>, but instead provide a basis to build your own code on top of.</p> <p><code>Moose</code> still uses the same format as MassiveOES for the line-by-line databases, since it makes them interoperable.</p> <p>You may be better served using <code>MassiveOES</code> or other programs, because of the following:</p> <ul> <li><code>Moose</code> does not give you tools to read, correct, or plot spectra<ul> <li>There are better, more feature complete libraries for that</li> </ul> </li> <li><code>Moose</code> lacks out-of-the-box fitting of multiple excited species not in equilibrium<ul> <li>See the examples pages to see how you could use <code>Moose</code> for fitting</li> <li>Or simply build upon <code>Moose</code> for your own custom fitting routines</li> </ul> </li> <li>The provided fitting examples simply recalculate the simulated spectrum for each fit iteration, which sacrifices some speed. <ul> <li>The benefit is that it can be run in parallel with ease.</li> <li>If you don't have a huge set of very similar data or complex fits, this should not be an issue</li> </ul> </li> </ul>"},{"location":"citing/","title":"Citing Moose","text":"<p><code>Moose</code> is made publicly available via it's <code>git</code> repository.</p> <p>To make it easier to cite and reference, you can also use the following Zenodo provided DOI link:</p> <p></p> <p>This link will resolve to the latest release of the source code on that platform.</p> <p>Whenever a new version is released on GitHub, this will be automatically updated.</p> <p>Each individual release is associated with it's own DOI as well.</p> <p>On the Zenodo page for the project or each release, you can obtain the citation information for <code>Moose</code> itself.</p> <p>Please also make sure to cite the original sources and authors of the databases that you use.</p>"},{"location":"citing/#original-sources-for-databases","title":"Original sources for databases","text":"<p>The table below summarizes the data sources for the databases that can be used.</p> <p>The majority of these have been compiled into database files by the original authors of MassiveOES.</p> Database Source DOI OHAX J. Luque and D.R. Crosley, J. Chem. Phys., 109, 439 (1998) https://doi.org/10.1063/1.476582 OHAX L.R. Williams and D.R. Crosley, J. Chem. Phys, 104, 6507 (1996) https://doi.org/10.1063/1.471371 OHAX Kristen L. Steffens, Jorge Luque, Jay B. Jeffries, David R. Crosley;  J. Chem. Phys. 15 April 1997; 106 (15): 6262\u20136267. https://doi.org/10.1063/1.473644 N\\(_2^+\\)BX J. Luque and D.R. Crosley, \u201cLIFBASE: Database and Spectral Simulation Program (Version 1.5) \u201d, SRI International Report MP 99-009 (1999). NHAX Western C 2016 PGOPHER\u2014a program for simulating rotational structure, Version 9.0.100, University of Bristol NHAX Ram R and Bernath P 2010 J. Mol. Spectrosc. 260 115\u20139 https://doi.org/10.1016/j.jms.2010.01.006 NHAX Lents J 1973 J. Quant. Spectrosc. Radiat. Transfer 13 297\u2013310 https://doi.org/10.1016/0022-4073(73)90061-7 NHAX Seong J, Park J K and Sun H 1994 Chem. Phys. Lett. 228 443\u201350 https://doi.org/10.1016/j.jms.2010.01.006 NOBX J. Luque and D.R. Crosley, \u201cLIFBASE: Database and Spectral Simulation Program (Version 1.5) \u201d, SRI International Report MP 99-009 (1999). N\\(_2\\)CB Nassar H, Pellerin S, Musiol K, Martinie O, Pellerin N and Cormier J 2004. Phys. D: Appl. Phys. 37 1904 https://doi.org/10.1088/0022-3727/37/14/005 N\\(_2\\)CB Laux C O and Kruger C H 1992 J. Quant. Spectrosc. Radiat. Transfer 48 9\u201324 https://doi.org/10.1016/0022-4073(92)90003-M N\\(_2\\)CB Faure G and Shko\u2019nik S 1998 J. Phys. D: Appl. Phys. 31 1212 https://doi.org/10.1088/0022-3727/31/10/013 C\\(_2\\) Swan James S.A. Brooke and Peter F. Bernath and Timothy W. Schmidt and George B. Bacskay; Journal of Quantitative Spectroscopy and Radiative Transfer; 2013 https://doi.org/10.1016/j.jqsrt.2013.02.025 C\\(_2\\) Swan Carbone, Emile and D'Isa, Federico and Hecimovic, Ante and Fantz, Ursel; PSST; 2020; https://doi.org/10.1088/1361-6595/ab74b4 CNBX Carbone, Emile and D'Isa, Federico and Hecimovic, Ante and Fantz, Ursel; PSST; 2020; https://doi.org/10.1088/1361-6595/ab74b4 <p>Info</p> <p>The databases named <code>C2_swan_J300.db</code> and <code>CNBX.db</code> were compiled by Emile Carbone et al 2020 Plasma Sources Sci. Technol. 29 055003.</p>"},{"location":"citing/#publications-introducing-massiveoes","title":"Publications introducing MassiveOES","text":"<p>Info</p> <p>VOR\u00c1\u010c, Jan; SYNEK, Petr; PROCH\u00c1ZKA, Vojt\u011bch; HODER, Tom\u00e1\u0161. State-by-state emission spectra fitting for non-equilibrium plasmas: OH spectra of surface barrier discharge at argon/water interface. Journal of Physics D: Applied Physics. 2017, 50(29), 294002. DOI: 10.1088/1361-6463/aa7570.</p> <p>Info</p> <p>VOR\u00c1\u010c, Jan; SYNEK, Petr; POTO\u010c\u0147\u00c1KOV\u00c1, Lucia; HNILICA, Jaroslav; KUDRLE, V\u00edt. Batch processing of overlapping molecular spectra as a tool for spatio-temporal diagnostics of power modulated microwave plasma jet. Plasma Sources Science and Technology 26.2 (2017), 025010. DOI: 10.1088/1361-6595/aa51f0.</p>"},{"location":"citing/#copyright-notice-from-massiveoes","title":"Copyright notice from MassiveOES","text":"<p>The original software is massiveOES developed by the Masaryk University available from: https://bitbucket.org/OES_muni/massiveoes.</p>"},{"location":"examples/","title":"Examples of using <code>Moose</code>","text":"<p><code>Moose</code> is meant to be simple, leaving it up to you how you'd like to integrate in your workflow.</p> <p>To give you some inspiration on getting started, we have a number of examples.</p> <p>These examples all demonstrate how you could use <code>Moose</code> to fit emission spectra and (interactively) plot the results with different backends.</p> <p>You can find the source files for the interactive notebooks and sample files via this link.</p> <p>If you want to try them out immediately, check out the live environment via Binder:</p> <p></p> <p>Examples have additional dependencies</p> <p>Note however that these examples may rely on additional dependencies, that need to be installed in your environment if you want to execute them yourself.</p> <p>See the getting started page on how to install these alongside <code>Moose</code>.</p> <p>However, if you use the examples hosted with Binder you can get started immediately.</p>"},{"location":"examples/#interactive-plotting-examples","title":"Interactive plotting examples","text":"<p>Interactive viewing and fitting of data is a common scenario where <code>Moose</code> may be helpful.</p> <p>These examples demonstrate how you could use different plotting backends to achieve this.</p> <ul> <li>Interactive Bokeh</li> <li>Interactive Plotly</li> <li>Interactive Matplotlib</li> <li>Different fitting backends</li> <li>Parallel fitting with Dask</li> <li>Spectra with multiple species</li> </ul> <p>Interactive features only work locally</p> <p>While some degree of interaction is possible from your browser, these example notebooks must be run (locally) in a python environment to do everything. You can find these example notebooks and the used data in the <code>docs/examples</code> folder of the <code>git</code> repository.</p> <p>Most of these examples rely on <code>lmfit</code> to perform the fitting of the spectra.</p> <p>The fitting is started via the <code>cb_fit</code> function, which is a callback that is invoked when pressing the <code>Fit</code> button in the simple UI that is created for most of the examples.</p>"},{"location":"get_started/","title":"Installing <code>Moose</code>","text":"<p><code>Moose</code> can be installed with <code>pip</code> to get the latest release, note that on PyPI it is known as <code>moose-spectra</code>:</p> <pre><code>pip install moose-spectra\n</code></pre> <p>Alternatively you can grab a copy or clone the source code from the git repository.</p> <p>Simply execute the following command in the terminal, from the location were you stored the source code:</p> <pre><code>pip install .\n</code></pre> <p>You can also install several optional dependencies alongside <code>Moose</code> for fitting spectra, interactive plotting, or locally updating these documentation pages.</p> <p>To do that run one of the following commands:</p> <pre><code># installs lmfit dependency\npip install moose-spectra[fit]\n\n# install doc page dependencies\npip install moose-spectra[docs]\n\n# install dependencies for running the examples\npip install moose-spectra[examples]\n\n# install the all the above dependencies\npip install moose-spectra[all] \n</code></pre>"},{"location":"get_started/#how-to-use-moose","title":"How to use <code>Moose</code>","text":"<p>A basic example demonstrating how to simulate and fit a spectrum is as follows.</p> <ol> <li> <p>Query a database for the emission system of interest, which is done with <code>query_DB</code>. This function will look for databases in the location where <code>Moose</code> has been installed, but it can also be provided with a path to your own compatible database. See the code reference for more information.</p> </li> <li> <p>Create a sample spectrum and add noise to it. To do this, first call the <code>model_for_fit</code> function, which is a high level function to calculate a spectrum, given line positions, temperatures, broadening parameters, and so forth.</p> </li> <li> <p>Next prepare to fit this simulated spectrum. Create an <code>lmfit.Model</code>, by wrapping the <code>model_for_fit</code> function and passing in the database as well to the wrapper. </p> </li> <li> <p>As initial guess and bounds for the fit parameters, create an <code>lmfit.Parameters</code> object. For simplicity you can set these with some default values using <code>Moose.default_params</code>.</p> </li> </ol> <pre><code>import Moose\nimport numpy as np\nimport lmfit\n\ndb = Moose.query_DB('N2CB', wl=(320,390)) # Restrict to wavelength between 320 and 390 nm\n\nx = np.linspace(320,390,2000)\n\nsimulated = Moose.model_for_fit(x,sigma=0.01,gamma=0.01,mu=0.5,T_rot=1000, T_vib=5000, sim_db=db)\n\ny = simulated + np.random.uniform(0,0.1,simulated.shape[0]) # add noise\n\nmodel = lmfit.Model(Moose.model_for_fit, sim_db=db)\nparams = lmfit.create_params(**Moose.default_params)\n\nresult = model.fit(y, x=x, params=params)\n\nresult.plot()\n</code></pre> <p>For more examples see the examples section</p>"},{"location":"examples/Moose_fitting_backends/","title":"Using different fitting backends","text":"In\u00a0[4]: Copied! <pre>import Moose\nimport lmfit\nfrom scipy.optimize import curve_fit\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom functools import partial\n\ndf = pd.read_csv('./N2SPS/20220302_s01_sig.cam', sep='\\t', header=1, names=['Wavelength', 'I'])\ndf['Norm'] = (df['I']-df['I'].min())/(df['I'].max()-df['I'].min())\n\ndb = Moose.query_DB('N2CB', (320,340))\nmodel = lmfit.Model(Moose.model_for_fit, sim_db = db)\nparams = lmfit.create_params(**Moose.default_params)\n</pre> import Moose import lmfit from scipy.optimize import curve_fit import pandas as pd import matplotlib.pyplot as plt from functools import partial  df = pd.read_csv('./N2SPS/20220302_s01_sig.cam', sep='\\t', header=1, names=['Wavelength', 'I']) df['Norm'] = (df['I']-df['I'].min())/(df['I'].max()-df['I'].min())  db = Moose.query_DB('N2CB', (320,340)) model = lmfit.Model(Moose.model_for_fit, sim_db = db) params = lmfit.create_params(**Moose.default_params)  In\u00a0[5]: Copied! <pre>result_lmfit = model.fit(df['Norm'].values, x = df['Wavelength'].values, params=params)\nresult_scipy =curve_fit(partial(Moose.model_for_fit, sim_db=db), xdata=df['Wavelength'].values, ydata=df['Norm'].values, p0=[v['value'] for v in Moose.default_params.values()], bounds = ([params[p].min for p in params],[params[p].max for p in params]))\n</pre> result_lmfit = model.fit(df['Norm'].values, x = df['Wavelength'].values, params=params) result_scipy =curve_fit(partial(Moose.model_for_fit, sim_db=db), xdata=df['Wavelength'].values, ydata=df['Norm'].values, p0=[v['value'] for v in Moose.default_params.values()], bounds = ([params[p].min for p in params],[params[p].max for p in params]))  In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots(2,1, sharex=True, tight_layout=True, gridspec_kw={'hspace':0, 'height_ratios':[2,1]})\ndf.plot(x='Wavelength', y='Norm', ax=ax[0], label='Measurement')\nax[0].plot(df['Wavelength'], result_lmfit.best_fit, label='Lmfit')\nax[0].plot(df['Wavelength'], Moose.model_for_fit(df['Wavelength'].values, *result_scipy[0], sim_db=db), label='Scipy', ls='--', alpha=0.7)\nax[0].legend(title='Fit')\n\n# ax[1].plot(df['Wavelength'], result_lmfit.residual - (Moose.model_for_fit(df['Wavelength'].values, *result_scipy[0], sim_db=db)-df['Norm']), label='Difference')\nax[1].plot(df['Wavelength'], result_lmfit.residual, label='Lmfit')\nax[1].plot(df['Wavelength'], Moose.model_for_fit(df['Wavelength'].values, *result_scipy[0], sim_db=db)-df['Norm'], label='Scipy', alpha=0.7, ls='--')\nax[1].legend(title='Residual')\nax[1].set_xlabel('$\\lambda$ (nm)')\n</pre> fig, ax = plt.subplots(2,1, sharex=True, tight_layout=True, gridspec_kw={'hspace':0, 'height_ratios':[2,1]}) df.plot(x='Wavelength', y='Norm', ax=ax[0], label='Measurement') ax[0].plot(df['Wavelength'], result_lmfit.best_fit, label='Lmfit') ax[0].plot(df['Wavelength'], Moose.model_for_fit(df['Wavelength'].values, *result_scipy[0], sim_db=db), label='Scipy', ls='--', alpha=0.7) ax[0].legend(title='Fit')  # ax[1].plot(df['Wavelength'], result_lmfit.residual - (Moose.model_for_fit(df['Wavelength'].values, *result_scipy[0], sim_db=db)-df['Norm']), label='Difference') ax[1].plot(df['Wavelength'], result_lmfit.residual, label='Lmfit') ax[1].plot(df['Wavelength'], Moose.model_for_fit(df['Wavelength'].values, *result_scipy[0], sim_db=db)-df['Norm'], label='Scipy', alpha=0.7, ls='--') ax[1].legend(title='Residual') ax[1].set_xlabel('$\\lambda$ (nm)') Out[6]: <pre>Text(0.5, 0, '$\\\\lambda$ (nm)')</pre> In\u00a0[7]: Copied! <pre>%timeit result_lmfit = model.fit(df['Norm'].values, x = df['Wavelength'].values, params=params)\n%timeit result_scipy = curve_fit(partial(Moose.model_for_fit, sim_db=db), xdata=df['Wavelength'].values, ydata=df['Norm'].values, p0=[params[p].value for p in params if params[p].vary is True],bounds = ([params[p].min for p in params if params[p].vary is True],[params[p].max for p in params if params[p].vary is True]))\n</pre> %timeit result_lmfit = model.fit(df['Norm'].values, x = df['Wavelength'].values, params=params) %timeit result_scipy = curve_fit(partial(Moose.model_for_fit, sim_db=db), xdata=df['Wavelength'].values, ydata=df['Norm'].values, p0=[params[p].value for p in params if params[p].vary is True],bounds = ([params[p].min for p in params if params[p].vary is True],[params[p].max for p in params if params[p].vary is True])) <pre>549 ms \u00b1 7.29 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n414 ms \u00b1 14.6 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Moose_fitting_backends/#using-different-fitting-backends","title":"Using different fitting backends\u00b6","text":"<p><code>Moose</code> itself provides no fitting methods, it simply tries to give you the tools to integrate it in your own workflow.</p> <p>While most examples use the lmfit package to demonstrate fitting spectra, you can also use <code>scipy.optimize.curve_fit</code> directly.</p> <p>Under the hood <code>lmfit</code> also relies on <code>scipy</code>, but their API is different for specifying fit parameters, initial values, bounds, etc.</p>"},{"location":"examples/Multiple_species/","title":"Multiple species","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nimport Moose\nimport lmfit\nimport pandas as pd\nimport numpy as np\nimport panel as pn\nimport panel.widgets as pnw\nfrom importlib import resources\nimport plotly.graph_objects as go\n\npn.extension('plotly')\n\nspecies = [p.stem for p in Path(resources.files(\"Moose\").joinpath(\"data\")).glob('*.db')]\nparams = lmfit.create_params(**Moose.default_params)\nparams['A'].vary = False \nparams['b'].vary = False\nparams['wl_pad'].value = 200\nparams['T_vib'].value= 4000\n\ndef load_species_db(name, *args):\n    df = Moose.query_DB(name,*args)\n    df['Species'] = name\n    return df.sort_values('air_wavelength')\n\ndbs = pd.concat([load_species_db(n,(300,500)) for n in ['N2CB', 'C2_swan']])\nx = np.linspace(300,500,2000)\ny = Moose.model_for_fit(x,**{p:params[p].value for p in params}, sim_db=dbs)\n</pre> from pathlib import Path import Moose import lmfit import pandas as pd import numpy as np import panel as pn import panel.widgets as pnw from importlib import resources import plotly.graph_objects as go  pn.extension('plotly')  species = [p.stem for p in Path(resources.files(\"Moose\").joinpath(\"data\")).glob('*.db')] params = lmfit.create_params(**Moose.default_params) params['A'].vary = False  params['b'].vary = False params['wl_pad'].value = 200 params['T_vib'].value= 4000  def load_species_db(name, *args):     df = Moose.query_DB(name,*args)     df['Species'] = name     return df.sort_values('air_wavelength')  dbs = pd.concat([load_species_db(n,(300,500)) for n in ['N2CB', 'C2_swan']]) x = np.linspace(300,500,2000) y = Moose.model_for_fit(x,**{p:params[p].value for p in params}, sim_db=dbs) In\u00a0[2]: Copied! <pre>fig = go.Figure()\nfig.add_scatter(x=x, y=y, name='Spectrum')\nfig.update_xaxes(title_text='\u03bb (nm)')\nfig.update_yaxes(title_text='I (a.u.)')\n\nselect_db = pnw.MultiChoice(value=['N2CB','C2_swan',],options = species, name='Select transitions', max_items=4)\nselect_range = pnw.RangeSlider(name='\u03bb (nm)', start=200, end=700, value=(300,500))\npop_fracs = [pnw.FloatInput(name=f'Pop. species {i}', value=1,start=0,end=100, step=0.1) for i in range(1,5)]\nstatus_msg = pnw.TextInput(name='Log', disabled=True)\n\ninput_widgets = {p:pnw.FloatSlider(name=p, value=params[p].value, start=params[p].min, end=params[p].max, step=params[p].value/10) for p in params if params[p].vary is True}\n\ndef cb_update_spectrum(event):\n    x = np.linspace(*select_range.value,2000)\n    if event.new != []:\n        dbs = pd.concat([load_species_db(n, select_range.value) for n in select_db.value])\n        y = np.zeros(x.shape[0])\n        for i, (n,g) in enumerate(dbs.groupby('Species')):\n            y+=Moose.model_for_fit(x,**{k:v.value for k,v in input_widgets.items()}, **{p:params[p].value for p in params if p not in input_widgets.keys()}, sim_db=g)*pop_fracs[i].value\n        with fig.batch_update():\n            fig.data[0].x = x\n            fig.data[0].y=y\n    else:\n        fig.data[0].x = x\n        fig.data[0].y = np.zeros(x.shape[0])\n        status_msg.value = \"Please select at least one species\"\n    \n\nfor wid in list(input_widgets.values())+[select_range,select_db]+pop_fracs:\n    if hasattr(wid,'value_throttled'):\n        to_watch = 'value_throttled'\n    else:\n        to_watch = 'value'\n    wid.param.watch(cb_update_spectrum,to_watch)\n\nlayout = pn.Column(pn.pane.Plotly(fig, sizing_mode='stretch_width'),pn.FlexBox(select_db, select_range, status_msg), pn.FlexBox(*input_widgets.values()), pn.Row(*pop_fracs))\nlayout\n</pre> fig = go.Figure() fig.add_scatter(x=x, y=y, name='Spectrum') fig.update_xaxes(title_text='\u03bb (nm)') fig.update_yaxes(title_text='I (a.u.)')  select_db = pnw.MultiChoice(value=['N2CB','C2_swan',],options = species, name='Select transitions', max_items=4) select_range = pnw.RangeSlider(name='\u03bb (nm)', start=200, end=700, value=(300,500)) pop_fracs = [pnw.FloatInput(name=f'Pop. species {i}', value=1,start=0,end=100, step=0.1) for i in range(1,5)] status_msg = pnw.TextInput(name='Log', disabled=True)  input_widgets = {p:pnw.FloatSlider(name=p, value=params[p].value, start=params[p].min, end=params[p].max, step=params[p].value/10) for p in params if params[p].vary is True}  def cb_update_spectrum(event):     x = np.linspace(*select_range.value,2000)     if event.new != []:         dbs = pd.concat([load_species_db(n, select_range.value) for n in select_db.value])         y = np.zeros(x.shape[0])         for i, (n,g) in enumerate(dbs.groupby('Species')):             y+=Moose.model_for_fit(x,**{k:v.value for k,v in input_widgets.items()}, **{p:params[p].value for p in params if p not in input_widgets.keys()}, sim_db=g)*pop_fracs[i].value         with fig.batch_update():             fig.data[0].x = x             fig.data[0].y=y     else:         fig.data[0].x = x         fig.data[0].y = np.zeros(x.shape[0])         status_msg.value = \"Please select at least one species\"       for wid in list(input_widgets.values())+[select_range,select_db]+pop_fracs:     if hasattr(wid,'value_throttled'):         to_watch = 'value_throttled'     else:         to_watch = 'value'     wid.param.watch(cb_update_spectrum,to_watch)  layout = pn.Column(pn.pane.Plotly(fig, sizing_mode='stretch_width'),pn.FlexBox(select_db, select_range, status_msg), pn.FlexBox(*input_widgets.values()), pn.Row(*pop_fracs)) layout Out[2]: In\u00a0[3]: Copied! <pre>def model_two_species(x:np.array, mu:float=0,sigma:float=0.01,gamma:float=0.01,T_rot_1:float=300,T_rot_2:float=300,T_vib:float=300, ratio:float=1, A:float=1,b:float=0,resolution:int=100, wl_pad:float=10,sim_db1=None,sim_db2=None):\n    \"\"\"A model function that combines two line-by-line dataframes for two species.\n    The respective contributions between the two species are scaled according to the `ratio` argument\"\"\"\n    sticks = np.concatenate([Moose.create_stick_spectrum(300,T_rot_1,sim_db1), Moose.create_stick_spectrum(T_vib,T_rot_2,sim_db2)*np.array([1,ratio])])\n    equid = Moose.equidistant_mesh(sticks[sticks[:,0].argsort()],wl_pad,resolution)\n    v = Moose.apply_voigt(equid,sigma, gamma)\n    matched = Moose.match_spectra((x-mu).reshape(-1,1), v)\n    matched[:,1] = (matched[:,1]-matched[:,1].min())/(matched[:,1].max()-matched[:,1].min())\n\n    return A*matched[:,1]+b\n\n\ndb1 = Moose.query_DB('N2CB', (350,400))\ndb2 = Moose.query_DB('CNBX', (350,400))\n\nx=np.linspace(370,390,1000)\ny=model_two_species(x,0,0.1,0.1,300,300,300,1,sim_db1=db1,sim_db2=db2)\n</pre> def model_two_species(x:np.array, mu:float=0,sigma:float=0.01,gamma:float=0.01,T_rot_1:float=300,T_rot_2:float=300,T_vib:float=300, ratio:float=1, A:float=1,b:float=0,resolution:int=100, wl_pad:float=10,sim_db1=None,sim_db2=None):     \"\"\"A model function that combines two line-by-line dataframes for two species.     The respective contributions between the two species are scaled according to the `ratio` argument\"\"\"     sticks = np.concatenate([Moose.create_stick_spectrum(300,T_rot_1,sim_db1), Moose.create_stick_spectrum(T_vib,T_rot_2,sim_db2)*np.array([1,ratio])])     equid = Moose.equidistant_mesh(sticks[sticks[:,0].argsort()],wl_pad,resolution)     v = Moose.apply_voigt(equid,sigma, gamma)     matched = Moose.match_spectra((x-mu).reshape(-1,1), v)     matched[:,1] = (matched[:,1]-matched[:,1].min())/(matched[:,1].max()-matched[:,1].min())      return A*matched[:,1]+b   db1 = Moose.query_DB('N2CB', (350,400)) db2 = Moose.query_DB('CNBX', (350,400))  x=np.linspace(370,390,1000) y=model_two_species(x,0,0.1,0.1,300,300,300,1,sim_db1=db1,sim_db2=db2) In\u00a0[4]: Copied! <pre>df = pd.read_csv(\"CN/370-400nm_9ns_calib.txt\").dropna()\n\nmodel = lmfit.Model(model_two_species, sim_db1=db1, sim_db2=db2)\nfit_params = lmfit.create_params(\n    **{k: v for k, v in Moose.default_params.items() if k not in [\"T_rot\"]}\n)\nfit_params.add(\"T_rot_1\", value=1000, min=300, max=1e4)\nfit_params.add(\"T_rot_2\", value=6000, min=300, max=1e4)\nfit_params.add(\"ratio\", value=1, min=0, max=100)\n\n\nfig_fit = go.Figure()\nfig_fit.add_scatter(x=df[\"Wavelength\"], y=df[\"I\"], name=\"Spectrum\")\nfig_fit.add_scatter(\n    x=df[\"Wavelength\"],\n    y=model.eval(x=df[\"Wavelength\"].values, params=fit_params),\n    name=\"Fit\",\n)\nfig_fit.add_scatter(x=df[\"Wavelength\"], y=np.zeros(df.shape[0]), name=\"Residual\")\n\nfig_fit.update_xaxes(title_text=\"\u03bb (nm)\")\nfig_fit.update_yaxes(title_text=\"I (a.u.)\")\n\nbtn_fit = pnw.Button(name=\"Fit\", button_type=\"primary\")\nwidgets = {\n    p: pnw.FloatInput(name=p, value=fit_params[p].value)\n    for p in fit_params\n    if p not in [\"A\", \"b\"]\n}\n\n\ndef iter_cb(params, iter, resid, *args, **kwargs):\n    for p in params:\n        if p not in [\"A\", \"b\"]:\n            widgets[p].value = params[p].value\n    if iter % 10 == 0:\n        with fig_fit.batch_update():\n            fig_fit.data[2].y = resid\n            # fig_fit.data[1].y = model_two_species(**params.valuesdict(),**kwargs, sim_db1=db1,sim_db)\n            fig_fit.data[1].y = model.eval(params=params, x=kwargs.get(\"x\"))\n\n\ndef cb_fit(event):\n    btn_fit.button_type = \"warning\"\n    result = model.fit(\n        df[\"I\"].values, x=df[\"Wavelength\"].values, params=fit_params, iter_cb=iter_cb\n    )\n    btn_fit.button_type = \"primary\"\n    iter_cb(result.params, -10, result.residual, x=df[\"Wavelength\"].values)\n\n\nbtn_fit.on_click(cb_fit)\n\nlayout = pn.Column(\n    pn.pane.Plotly(fig_fit, sizing_mode=\"stretch_width\"),\n    btn_fit,\n    pn.FlexBox(*widgets.values()),\n)\nlayout\n</pre> df = pd.read_csv(\"CN/370-400nm_9ns_calib.txt\").dropna()  model = lmfit.Model(model_two_species, sim_db1=db1, sim_db2=db2) fit_params = lmfit.create_params(     **{k: v for k, v in Moose.default_params.items() if k not in [\"T_rot\"]} ) fit_params.add(\"T_rot_1\", value=1000, min=300, max=1e4) fit_params.add(\"T_rot_2\", value=6000, min=300, max=1e4) fit_params.add(\"ratio\", value=1, min=0, max=100)   fig_fit = go.Figure() fig_fit.add_scatter(x=df[\"Wavelength\"], y=df[\"I\"], name=\"Spectrum\") fig_fit.add_scatter(     x=df[\"Wavelength\"],     y=model.eval(x=df[\"Wavelength\"].values, params=fit_params),     name=\"Fit\", ) fig_fit.add_scatter(x=df[\"Wavelength\"], y=np.zeros(df.shape[0]), name=\"Residual\")  fig_fit.update_xaxes(title_text=\"\u03bb (nm)\") fig_fit.update_yaxes(title_text=\"I (a.u.)\")  btn_fit = pnw.Button(name=\"Fit\", button_type=\"primary\") widgets = {     p: pnw.FloatInput(name=p, value=fit_params[p].value)     for p in fit_params     if p not in [\"A\", \"b\"] }   def iter_cb(params, iter, resid, *args, **kwargs):     for p in params:         if p not in [\"A\", \"b\"]:             widgets[p].value = params[p].value     if iter % 10 == 0:         with fig_fit.batch_update():             fig_fit.data[2].y = resid             # fig_fit.data[1].y = model_two_species(**params.valuesdict(),**kwargs, sim_db1=db1,sim_db)             fig_fit.data[1].y = model.eval(params=params, x=kwargs.get(\"x\"))   def cb_fit(event):     btn_fit.button_type = \"warning\"     result = model.fit(         df[\"I\"].values, x=df[\"Wavelength\"].values, params=fit_params, iter_cb=iter_cb     )     btn_fit.button_type = \"primary\"     iter_cb(result.params, -10, result.residual, x=df[\"Wavelength\"].values)   btn_fit.on_click(cb_fit)  layout = pn.Column(     pn.pane.Plotly(fig_fit, sizing_mode=\"stretch_width\"),     btn_fit,     pn.FlexBox(*widgets.values()), ) layout Out[4]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/Multiple_species/#multiple-species","title":"Multiple species\u00b6","text":"<p>This example demonstrates how to combine multiple species in one go for the simulation.</p> <p>To do that, it simply concatenates the databases for two or more species.</p> <p>To ensure we retain the information which line corresponds with which species, we add a <code>species</code> column with this information.</p> <p>For simplicity of this interactive example, the spectra are simulated based on the linestrength only, inherently assuming an equal amount for each selected species.</p> <p>Furthermore, it assumes equilibration between rotational or vibrational states, such that a single $T_{rot}$ and $T_{vib}$ can be used to describe the spectrum.</p>"},{"location":"examples/Multiple_species/#model-and-fit-the-combined-spectrum-of-two-species","title":"Model and fit the combined spectrum of two species\u00b6","text":"<p>Alternatively, the provided sample file contains emission of the CN violet system and the N$_2$ second positive system.</p> <p>In the case of the former there are multiple overlapping vibrational bands, but the latter only contains one vibrational band, for the (0,2) transition.</p> <p>Thus to model the spectrum we allow for a vibrational and rotational temperature for CN, while N$_2$ only is assigned a rotational temperature.</p>"},{"location":"examples/bokeh/","title":"Interactive Bokeh plot","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nimport numpy as np\nimport pandas as pd\nimport lmfit\nimport Moose\n\nfrom bokeh.plotting import figure\nfrom bokeh.io import output_notebook\nfrom bokeh.models import ColumnDataSource as CDS\n\nimport panel as pn\nimport panel.widgets as pnw\noutput_notebook()\npn.extension()\n\n\n\nfs =list(Path(\"N2SPS\").glob('*'))\n\nsample = pd.read_csv(fs[0], sep='\\t', header=1, names=['Wavelength', 'I'])\nsample['Norm'] = (sample['I']-sample['I'].min())/(sample['I'].max()-sample['I'].min())\n\ndb = Moose.query_DB('N2CB')\nmodel = lmfit.Model(Moose.model_for_fit, sim_db = db)\nparams = lmfit.create_params(**Moose.default_params)\n</pre> from pathlib import Path import numpy as np import pandas as pd import lmfit import Moose  from bokeh.plotting import figure from bokeh.io import output_notebook from bokeh.models import ColumnDataSource as CDS  import panel as pn import panel.widgets as pnw output_notebook() pn.extension()    fs =list(Path(\"N2SPS\").glob('*'))  sample = pd.read_csv(fs[0], sep='\\t', header=1, names=['Wavelength', 'I']) sample['Norm'] = (sample['I']-sample['I'].min())/(sample['I'].max()-sample['I'].min())  db = Moose.query_DB('N2CB') model = lmfit.Model(Moose.model_for_fit, sim_db = db) params = lmfit.create_params(**Moose.default_params) Loading BokehJS ... In\u00a0[2]: Copied! <pre>fig = figure(sizing_mode='stretch_width', height=250)\n\ncds_data = CDS(sample)\ncds_sim = CDS({\"Wavelength\":sample['Wavelength'], 'Guess':model.eval(x=sample['Wavelength'].values, params=params),'Fit': np.zeros(sample.shape[0]),'Residual': np.zeros(sample.shape[0])})\n\nline_data = fig.line(source=cds_data, x='Wavelength', y='Norm', line_width=3, legend_label='Measured')\nfig.line(source=cds_sim, x='Wavelength', y='Guess', line_width=3, legend_label='Guess', color='red', line_dash='dashed')\nfig.line(source=cds_sim, x='Wavelength', y='Fit', line_width=3, legend_label='Fit', color='green')\nfig.line(source=cds_sim, x='Wavelength', y='Residual', line_width=3, legend_label='Residual', color='purple')\n\n# Create some widgets to interact with and show the output\nlook = {'sizing_mode': 'stretch_width'}\n\nwids = {p:pnw.FloatSlider(name = p, start=params[p].min, end=params[p].max, value=params[p].value, step=0.01,**look) for p in params if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']}\nwids_result = {p:pnw.FloatInput(name = p,**look) for p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']}\nbtn_fit = pnw.Button(name='Fit',button_type='primary', **look)\nbtn_read = pnw.Button(name='Read file',button_type='primary', **look)\nselect_file = pnw.Select(name='Select file', options = fs, **look)\n\nlayout = pn.Column(pn.pane.Bokeh(fig),pn.Row(*wids.values()), pn.Row(btn_fit, select_file), pn.Row(*wids_result.values(), **look),**look)\n\n# Create and register callbacks\ndef update_simulation(event):\n    \"\"\"Callback to update the preview for finetuning the initial guess\"\"\"\n    # x = cds_data.data['Wavelength']\n    x = line_data.data_source.data['Wavelength']\n    ynew = model.eval(x=x, **{n:w.value for n,w in wids.items()})\n    data = cds_sim.data.copy()\n    data['Guess'] = ynew\n    cds_sim.data = data\n\ndef fit_iter_cb(pars, iteration, resid,*args, **kwargs):\n    \"\"\"Callback to update on fit iterations, so we can see the progress\"\"\"\n    for p in pars:\n        if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']:\n            wids_result[p].value = pars[p].value\n    if iteration % 20 ==0:\n        data= line_data.data_source.data\n        sim_data = cds_sim.data.copy()\n        sim_data['Wavelength'] = data['Wavelength']\n        sim_data['Fit'] =  model.eval(x=data['Wavelength'], **pars)\n        sim_data['Residual'] = resid\n        cds_sim.data = sim_data\n\ndef cb_fit(*args):\n    \"\"\"Callback to start the fitting routine.\n    Upon completion it makes the button green, to show the fit completed.\n    The fitted parameters are updated in `params` upon completion\"\"\"\n    btn_fit.button_type='danger'\n    data= line_data.data_source.data\n    result = model.fit(data['Norm'], x=data['Wavelength'], params=params, iter_cb= fit_iter_cb, max_nfev=300)\n    btn_fit.button_type='success'\n    for p in  result.params:\n        params[p].value=result.params[p].value\n    fit_iter_cb(result.params, 20, result.residual) # force update of plot with result when done \n\ndef read_file(*args):\n    df = pd.read_csv(select_file.value, sep='\\t', header=1, names=['Wavelength', 'I'])\n    df['Norm'] = (df['I']-df['I'].min())/(df['I'].max()-df['I'].min())\n    cds_data.data = {\"index\": df.index.values,\"Wavelength\":df['Wavelength'].values, 'I': df['I'].values, 'Norm': df['Norm'].values}\n    sim_data = cds_sim.data.copy()\n    sim_data['Wavelength'] = df['Wavelength'].values\n    sim_data['Guess'] = model.eval(x=df['Wavelength'].values, params=params)\n    sim_data['Fit'] = np.zeros(df.shape[0])\n    sim_data['Residual'] = np.zeros(df.shape[0])\n    cds_sim.data = sim_data\n\nfor n,w in wids.items():\n    w.param.watch(update_simulation,'value')\nbtn_fit.on_click(cb_fit)\n\nselect_file.param.watch(read_file, 'value')\n\nlayout\n</pre> fig = figure(sizing_mode='stretch_width', height=250)  cds_data = CDS(sample) cds_sim = CDS({\"Wavelength\":sample['Wavelength'], 'Guess':model.eval(x=sample['Wavelength'].values, params=params),'Fit': np.zeros(sample.shape[0]),'Residual': np.zeros(sample.shape[0])})  line_data = fig.line(source=cds_data, x='Wavelength', y='Norm', line_width=3, legend_label='Measured') fig.line(source=cds_sim, x='Wavelength', y='Guess', line_width=3, legend_label='Guess', color='red', line_dash='dashed') fig.line(source=cds_sim, x='Wavelength', y='Fit', line_width=3, legend_label='Fit', color='green') fig.line(source=cds_sim, x='Wavelength', y='Residual', line_width=3, legend_label='Residual', color='purple')  # Create some widgets to interact with and show the output look = {'sizing_mode': 'stretch_width'}  wids = {p:pnw.FloatSlider(name = p, start=params[p].min, end=params[p].max, value=params[p].value, step=0.01,**look) for p in params if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']} wids_result = {p:pnw.FloatInput(name = p,**look) for p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']} btn_fit = pnw.Button(name='Fit',button_type='primary', **look) btn_read = pnw.Button(name='Read file',button_type='primary', **look) select_file = pnw.Select(name='Select file', options = fs, **look)  layout = pn.Column(pn.pane.Bokeh(fig),pn.Row(*wids.values()), pn.Row(btn_fit, select_file), pn.Row(*wids_result.values(), **look),**look)  # Create and register callbacks def update_simulation(event):     \"\"\"Callback to update the preview for finetuning the initial guess\"\"\"     # x = cds_data.data['Wavelength']     x = line_data.data_source.data['Wavelength']     ynew = model.eval(x=x, **{n:w.value for n,w in wids.items()})     data = cds_sim.data.copy()     data['Guess'] = ynew     cds_sim.data = data  def fit_iter_cb(pars, iteration, resid,*args, **kwargs):     \"\"\"Callback to update on fit iterations, so we can see the progress\"\"\"     for p in pars:         if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']:             wids_result[p].value = pars[p].value     if iteration % 20 ==0:         data= line_data.data_source.data         sim_data = cds_sim.data.copy()         sim_data['Wavelength'] = data['Wavelength']         sim_data['Fit'] =  model.eval(x=data['Wavelength'], **pars)         sim_data['Residual'] = resid         cds_sim.data = sim_data  def cb_fit(*args):     \"\"\"Callback to start the fitting routine.     Upon completion it makes the button green, to show the fit completed.     The fitted parameters are updated in `params` upon completion\"\"\"     btn_fit.button_type='danger'     data= line_data.data_source.data     result = model.fit(data['Norm'], x=data['Wavelength'], params=params, iter_cb= fit_iter_cb, max_nfev=300)     btn_fit.button_type='success'     for p in  result.params:         params[p].value=result.params[p].value     fit_iter_cb(result.params, 20, result.residual) # force update of plot with result when done   def read_file(*args):     df = pd.read_csv(select_file.value, sep='\\t', header=1, names=['Wavelength', 'I'])     df['Norm'] = (df['I']-df['I'].min())/(df['I'].max()-df['I'].min())     cds_data.data = {\"index\": df.index.values,\"Wavelength\":df['Wavelength'].values, 'I': df['I'].values, 'Norm': df['Norm'].values}     sim_data = cds_sim.data.copy()     sim_data['Wavelength'] = df['Wavelength'].values     sim_data['Guess'] = model.eval(x=df['Wavelength'].values, params=params)     sim_data['Fit'] = np.zeros(df.shape[0])     sim_data['Residual'] = np.zeros(df.shape[0])     cds_sim.data = sim_data  for n,w in wids.items():     w.param.watch(update_simulation,'value') btn_fit.on_click(cb_fit)  select_file.param.watch(read_file, 'value')  layout Out[2]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/bokeh/#interactive-bokeh-plot","title":"Interactive Bokeh plot\u00b6","text":"<p>This example demonstrates how to fit emission spectra using <code>Moose</code> and visualize the result with <code>Bokeh</code> in interactive mode.</p> <p>The initial guess of the parameters for the fits can be adjusted using the slider widgets in the minimal UI below.</p> <p>Once satisfied with the guess, pressing the <code>Fit</code> button will execute the <code>cb_fit</code> callback.</p> <p>This callback contains the actual call to fit the data.</p> <p>The fit procedure can be performed on either of two included sample files in the folder <code>./N2SPS</code>:</p> <ol> <li><p>A spectrum of the second positive system (0,0) band, as recorded at the start of a nanosecond repetitively pulsed discharge: <code>20220302_s01_sig.cam</code></p> </li> <li><p>A spectrum simulated by SpecAir as part of the unit test from RADIS</p> <ul> <li>See also: the corresponding GitHub page</li> <li>Or the notebook by the RADIS developers that demonstrates using MassiveOES</li> </ul> </li> </ol>"},{"location":"examples/dask/","title":"Parallelized batch fitting with","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport Moose\nimport lmfit\nimport distributed\nfrom functools import partial\nimport plotly.graph_objects as go\nimport panel as pn\n\npn.extension('plotly')\n\nx = np.linspace(320,390,2000)\ndb = Moose.query_DB('N2CB', wl=(x.min(), x.max()))\nmodel = lmfit.Model(Moose.model_for_fit, sim_db = db)\nparams = lmfit.create_params(**Moose.default_params)\n\nparams['T_rot'].max = 8000\nparams['T_vib'].max = 8000\nparams['A'].vary = False\n\n# start a cluster on the local machine and display client info\ncluster= distributed.LocalCluster()\nclient = cluster.get_client()\n</pre> import numpy as np import pandas as pd import matplotlib.pyplot as plt import Moose import lmfit import distributed from functools import partial import plotly.graph_objects as go import panel as pn  pn.extension('plotly')  x = np.linspace(320,390,2000) db = Moose.query_DB('N2CB', wl=(x.min(), x.max())) model = lmfit.Model(Moose.model_for_fit, sim_db = db) params = lmfit.create_params(**Moose.default_params)  params['T_rot'].max = 8000 params['T_vib'].max = 8000 params['A'].vary = False  # start a cluster on the local machine and display client info cluster= distributed.LocalCluster() client = cluster.get_client() In\u00a0[2]: Copied! <pre>def create_variables(params:lmfit.Parameters) -&gt; dict:\n    \"\"\"Creates some random values to simulate a spectrum, within defined bounds of the parameters\"\"\"\n    variables = {p:np.random.uniform(np.sign(params[p].min)*params[p].min*0.9, params[p].max*0.9) for p in params if params[p].vary is True}\n    return variables\n    \ndef create_spectrum(x:np.array, model:lmfit.Model, noise=0.1,**kwargs) -&gt; np.array:\n    \"\"\"Creates a spectrum with noise superimposed\"\"\"\n    spec =  model.eval(x=x, params=params,**kwargs)+np.random.uniform(0.0,noise,x.shape[0])\n    return (spec-spec.min())/(spec.max()-spec.min())\n\n\nvariables = [create_variables(params) for i in range(20)]\nspec = [create_spectrum(x,model,noise=0.2,**var) for var in variables]\n</pre> def create_variables(params:lmfit.Parameters) -&gt; dict:     \"\"\"Creates some random values to simulate a spectrum, within defined bounds of the parameters\"\"\"     variables = {p:np.random.uniform(np.sign(params[p].min)*params[p].min*0.9, params[p].max*0.9) for p in params if params[p].vary is True}     return variables      def create_spectrum(x:np.array, model:lmfit.Model, noise=0.1,**kwargs) -&gt; np.array:     \"\"\"Creates a spectrum with noise superimposed\"\"\"     spec =  model.eval(x=x, params=params,**kwargs)+np.random.uniform(0.0,noise,x.shape[0])     return (spec-spec.min())/(spec.max()-spec.min())   variables = [create_variables(params) for i in range(20)] spec = [create_spectrum(x,model,noise=0.2,**var) for var in variables] In\u00a0[3]: Copied! <pre>futures = client.map(partial(model.fit, x=x, params=params), spec)\n</pre> futures = client.map(partial(model.fit, x=x, params=params), spec) In\u00a0[4]: Copied! <pre>results = client.gather(futures)\n</pre> results = client.gather(futures) In\u00a0[5]: Copied! <pre>input_view_index = pn.widgets.Spinner(name='Index', start=0, end=len(results)-1, value=0)\noutput_params = {k:pn.widgets.FloatInput(name=k, value=results[0].params[k].value, disabled=True) for k in params if params[k].vary is True}\n\nfig = go.Figure()\nfig.add_scatter(x=x, y=spec[0], name='Spectrum')\nfig.add_scatter(x=x, y=results[0].eval(x=x), name='Fit')\nfig.add_scatter(x=x, y=results[0].residual, name='Residual')\n\nfig.update_xaxes(title_text='Wavelength (nm)')\nfig.update_yaxes(title_text='Norm. I. (a.u.)')\n\nlayout = pn.Column(pn.pane.Plotly(fig, sizing_mode='stretch_width'), input_view_index, pn.FlexBox(*output_params.values()))\n\ndef cb_update_view(*args):\n    with fig.batch_update():\n        fig.data[0].x = x\n        fig.data[0].y  =spec[input_view_index.value]\n        fig.data[1].x = x\n        fig.data[1].y  = results[input_view_index.value].eval(x=x)\n        fig.data[2].x = x\n        fig.data[2].y = results[input_view_index.value].residual\n        for p in results[input_view_index.value].params:\n            if params[p].vary is True:\n                output_params[p].value = results[input_view_index.value].params[p].value\n            \n\ninput_view_index.param.watch(cb_update_view, 'value_throttled')\n\nlayout\n</pre> input_view_index = pn.widgets.Spinner(name='Index', start=0, end=len(results)-1, value=0) output_params = {k:pn.widgets.FloatInput(name=k, value=results[0].params[k].value, disabled=True) for k in params if params[k].vary is True}  fig = go.Figure() fig.add_scatter(x=x, y=spec[0], name='Spectrum') fig.add_scatter(x=x, y=results[0].eval(x=x), name='Fit') fig.add_scatter(x=x, y=results[0].residual, name='Residual')  fig.update_xaxes(title_text='Wavelength (nm)') fig.update_yaxes(title_text='Norm. I. (a.u.)')  layout = pn.Column(pn.pane.Plotly(fig, sizing_mode='stretch_width'), input_view_index, pn.FlexBox(*output_params.values()))  def cb_update_view(*args):     with fig.batch_update():         fig.data[0].x = x         fig.data[0].y  =spec[input_view_index.value]         fig.data[1].x = x         fig.data[1].y  = results[input_view_index.value].eval(x=x)         fig.data[2].x = x         fig.data[2].y = results[input_view_index.value].residual         for p in results[input_view_index.value].params:             if params[p].vary is True:                 output_params[p].value = results[input_view_index.value].params[p].value               input_view_index.param.watch(cb_update_view, 'value_throttled')  layout Out[5]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/dask/#parallelized-batch-fitting-with-dask","title":"Parallelized batch fitting with <code>Dask</code>\u00b6","text":"<p>This example demonstrates how to fit a set of spectra in parallel, to make use of multiple CPU cores available on a system. To do this, it relies on the use of <code>Dask</code> to create a <code>distributed.LocalCluster</code> to sumbit work to.</p> <p>First we create a sample dataset to fit using the <code>create_variables</code> and <code>create_spectrum</code> functions.</p> <p>These we then submit to the cluster to fit using the <code>client.map</code> call.</p> <p>The <code>client.gather(futures)</code> call then collects our results, and the call will block untill the fitting is done.</p> <p>Once we have the results, these are visualized using <code>plotly</code> and <code>panel</code>, so we can inspect them individually.</p>"},{"location":"examples/matplotlib/","title":"Interactive Matplotlib","text":"In\u00a0[1]: Copied! <pre># %matplotlib widget\n%matplotlib ipympl\nfrom pathlib import Path\nimport numpy as np\nimport pandas as pd\nimport lmfit\nfrom functools import partial\nimport Moose\n\nimport matplotlib.pyplot as plt\n\nimport ipywidgets as widgets\nimport panel as pn\nimport panel.widgets as pnw\n\npn.extension(\"ipywidgets\")\n\n\nfs = list(Path(\"N2SPS\").glob(\"*.*\"))\n\nsample = pd.read_csv(\n    fs[0], sep=\"\\t\", header=1, names=[\"Wavelength\", \"I\"]\n)\nsample[\"Norm\"] = (sample[\"I\"] - sample[\"I\"].min()) / (\n    sample[\"I\"].max() - sample[\"I\"].min()\n)\n\ndb = Moose.query_DB(\"N2CB\", (320,450))\nmodel = lmfit.Model(Moose.model_for_fit, sim_db=db)\nparams = lmfit.create_params(**Moose.default_params)\n</pre> # %matplotlib widget %matplotlib ipympl from pathlib import Path import numpy as np import pandas as pd import lmfit from functools import partial import Moose  import matplotlib.pyplot as plt  import ipywidgets as widgets import panel as pn import panel.widgets as pnw  pn.extension(\"ipywidgets\")   fs = list(Path(\"N2SPS\").glob(\"*.*\"))  sample = pd.read_csv(     fs[0], sep=\"\\t\", header=1, names=[\"Wavelength\", \"I\"] ) sample[\"Norm\"] = (sample[\"I\"] - sample[\"I\"].min()) / (     sample[\"I\"].max() - sample[\"I\"].min() )  db = Moose.query_DB(\"N2CB\", (320,450)) model = lmfit.Model(Moose.model_for_fit, sim_db=db) params = lmfit.create_params(**Moose.default_params) In\u00a0[2]: Copied! <pre>with plt.ioff():\n    fig = plt.figure()\n    ax = plt.gca()\nline_measured = plt.plot(sample['Wavelength'], sample['Norm'], label='Measured')\nline_sim = plt.plot(sample['Wavelength'], model.eval(x=sample['Wavelength'].values, params=params), label='Guess')\nline_fit = plt.plot(sample['Wavelength'], np.zeros(sample.shape[0]), label='Fit')\nline_residual = plt.plot(sample['Wavelength'], np.zeros(sample.shape[0]), label='Residual')\n\nplt.legend()\nplt.xlabel('$\\lambda$ (nm)')\nplt.ylabel('I (a.u.)')\n\n\n# Create some widgets to interact with and show the output\nlook = {'sizing_mode': 'stretch_width'}\n\nwids = {p:pnw.FloatSlider(name = p, start=params[p].min, end=params[p].max, value=params[p].value, step=0.01,**look) for p in params if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']}\nwids_result = {p:pnw.FloatInput(name = p,**look) for p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']}\nbtn_fit = pnw.Button(name='Fit',button_type='primary', **look)\nselect_file = pnw.Select(name='Select file', options = fs, **look)\n\nlayout = pn.Column(pn.Row(*wids.values()), pn.Row(btn_fit, select_file), pn.Row(*wids_result.values(), **look), height=250,**look)\n\n# Create and register callbacks\ndef update_simulation(event):\n    \"\"\"Callback to update the preview for finetuning the initial guess\"\"\"\n    x = line_measured[0].get_data()[0]\n    ynew = model.eval(x=x, **{n:w.value for n,w in wids.items()})\n    line_sim[0].set_data(x,ynew)\n    fig.canvas.draw_idle()\n\ndef fit_iter_cb(pars, iteration, resid,*args, **kwargs):\n    \"\"\"Callback to update on fit iterations, so we can see the progress\"\"\"\n    for p in pars:\n        if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']:\n            wids_result[p].value = pars[p].value\n    if iteration % 20 ==0:\n        x = line_measured[0].get_data()[0]\n        ynew = model.eval(x=x, **pars)\n        line_fit[0].set_data(x,ynew)\n        line_residual[0].set_data(x,resid)\n\ndef cb_fit(*args):\n    \"\"\"Callback to start the fitting routine.\n    Upon completion it makes the button green, to show the fit completed.\n    The fitted parameters are updated in `params` upon completion\"\"\"\n    btn_fit.button_type='danger'\n    x,y = line_measured[0].get_data()\n    result = model.fit(y, x=x, params=params, iter_cb= fit_iter_cb, max_nfev=300)\n    btn_fit.button_type='success'\n    for p in  result.params:\n        params[p].value=result.params[p].value\n    fit_iter_cb(result.params, 20, result.residual) # force update of plot with result when done \n\ndef read_file(*args):\n    df = pd.read_csv(select_file.value, sep='\\t', header=1, names=['Wavelength', 'I'])\n    df['Norm'] = (df['I']-df['I'].min())/(df['I'].max()-df['I'].min())\n    line_measured[0].set_data(df['Wavelength'].values, df['Norm'].values)\n    line_sim[0].set_data(df['Wavelength'].values, model.eval(x=df['Wavelength'].values, params=params))\n    for line in [line_fit, line_residual]:\n        line[0].set_data(df['Wavelength'].values, np.zeros(df.shape[0]))\n    plt.xlim(df['Wavelength'].min(), df['Wavelength'].max())\n\nfor n,w in wids.items():\n    w.param.watch(update_simulation,'value')\nbtn_fit.on_click(cb_fit)\n\nselect_file.param.watch(read_file, 'value')\n\ndisplay(widgets.AppLayout(center=fig.canvas), layout)\n</pre> with plt.ioff():     fig = plt.figure()     ax = plt.gca() line_measured = plt.plot(sample['Wavelength'], sample['Norm'], label='Measured') line_sim = plt.plot(sample['Wavelength'], model.eval(x=sample['Wavelength'].values, params=params), label='Guess') line_fit = plt.plot(sample['Wavelength'], np.zeros(sample.shape[0]), label='Fit') line_residual = plt.plot(sample['Wavelength'], np.zeros(sample.shape[0]), label='Residual')  plt.legend() plt.xlabel('$\\lambda$ (nm)') plt.ylabel('I (a.u.)')   # Create some widgets to interact with and show the output look = {'sizing_mode': 'stretch_width'}  wids = {p:pnw.FloatSlider(name = p, start=params[p].min, end=params[p].max, value=params[p].value, step=0.01,**look) for p in params if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']} wids_result = {p:pnw.FloatInput(name = p,**look) for p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']} btn_fit = pnw.Button(name='Fit',button_type='primary', **look) select_file = pnw.Select(name='Select file', options = fs, **look)  layout = pn.Column(pn.Row(*wids.values()), pn.Row(btn_fit, select_file), pn.Row(*wids_result.values(), **look), height=250,**look)  # Create and register callbacks def update_simulation(event):     \"\"\"Callback to update the preview for finetuning the initial guess\"\"\"     x = line_measured[0].get_data()[0]     ynew = model.eval(x=x, **{n:w.value for n,w in wids.items()})     line_sim[0].set_data(x,ynew)     fig.canvas.draw_idle()  def fit_iter_cb(pars, iteration, resid,*args, **kwargs):     \"\"\"Callback to update on fit iterations, so we can see the progress\"\"\"     for p in pars:         if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']:             wids_result[p].value = pars[p].value     if iteration % 20 ==0:         x = line_measured[0].get_data()[0]         ynew = model.eval(x=x, **pars)         line_fit[0].set_data(x,ynew)         line_residual[0].set_data(x,resid)  def cb_fit(*args):     \"\"\"Callback to start the fitting routine.     Upon completion it makes the button green, to show the fit completed.     The fitted parameters are updated in `params` upon completion\"\"\"     btn_fit.button_type='danger'     x,y = line_measured[0].get_data()     result = model.fit(y, x=x, params=params, iter_cb= fit_iter_cb, max_nfev=300)     btn_fit.button_type='success'     for p in  result.params:         params[p].value=result.params[p].value     fit_iter_cb(result.params, 20, result.residual) # force update of plot with result when done   def read_file(*args):     df = pd.read_csv(select_file.value, sep='\\t', header=1, names=['Wavelength', 'I'])     df['Norm'] = (df['I']-df['I'].min())/(df['I'].max()-df['I'].min())     line_measured[0].set_data(df['Wavelength'].values, df['Norm'].values)     line_sim[0].set_data(df['Wavelength'].values, model.eval(x=df['Wavelength'].values, params=params))     for line in [line_fit, line_residual]:         line[0].set_data(df['Wavelength'].values, np.zeros(df.shape[0]))     plt.xlim(df['Wavelength'].min(), df['Wavelength'].max())  for n,w in wids.items():     w.param.watch(update_simulation,'value') btn_fit.on_click(cb_fit)  select_file.param.watch(read_file, 'value')  display(widgets.AppLayout(center=fig.canvas), layout) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/matplotlib/#interactive-matplotlib","title":"Interactive Matplotlib\u00b6","text":"<p>This example demonstrates how to fit emission spectra using <code>Moose</code> and visualize the result with <code>matplotlib</code> in interactive mode.</p> <p>The initial guess of the parameters for the fits can be adjusted using the slider widgets in the minimal UI below.</p> <p>Once satisfied with the guess, pressing the <code>Fit</code> button will execute the <code>cb_fit</code> callback.</p> <p>This callback contains the actual call to fit the data.</p> <p>The fit procedure can be performed on either of two included sample files in the folder <code>./N2SPS</code>:</p> <ol> <li><p>A spectrum of the second positive system (0,0) band, as recorded at the start of a nanosecond repetitively pulsed discharge: <code>20220302_s01_sig.cam</code></p> </li> <li><p>A spectrum simulated by SpecAir as part of the unit test from RADIS</p> <ul> <li>See also: the corresponding GitHub page</li> <li>Or the notebook by the RADIS developers that demonstrates using MassiveOES</li> </ul> </li> </ol>"},{"location":"examples/plotly/","title":"Interactive Plotly plot","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nimport numpy as np\nimport pandas as pd\nimport lmfit\nimport Moose\n\nimport plotly.graph_objects as go\n\nimport panel as pn\nimport panel.widgets as pnw\n\npn.extension('plotly')\n\n\nfs = list(Path(\"N2SPS\").glob(\"*.*\"))\n\nsample = pd.read_csv(fs[0], sep='\\t', header=1, names=['Wavelength', 'I'])\nsample['Norm'] = (sample['I']-sample['I'].min())/(sample['I'].max()-sample['I'].min())\n\ndb = Moose.query_DB('N2CB')\nmodel = lmfit.Model(Moose.model_for_fit, sim_db = db)\nparams = lmfit.create_params(**Moose.default_params)\n</pre> from pathlib import Path import numpy as np import pandas as pd import lmfit import Moose  import plotly.graph_objects as go  import panel as pn import panel.widgets as pnw  pn.extension('plotly')   fs = list(Path(\"N2SPS\").glob(\"*.*\"))  sample = pd.read_csv(fs[0], sep='\\t', header=1, names=['Wavelength', 'I']) sample['Norm'] = (sample['I']-sample['I'].min())/(sample['I'].max()-sample['I'].min())  db = Moose.query_DB('N2CB') model = lmfit.Model(Moose.model_for_fit, sim_db = db) params = lmfit.create_params(**Moose.default_params)  In\u00a0[2]: Copied! <pre># Set up the plot\n# fig = go.FigureWidget()\nfig = go.Figure()\nfig.add_scatter(x=sample['Wavelength'], y=sample['Norm'], name='Measured')\nfig.add_scatter(x=sample['Wavelength'], y=model.eval(x=sample['Wavelength'].values, params=params), name='Simulation', line_dash='dash')\nfig.add_scatter(x=sample['Wavelength'], y=np.zeros(sample.shape[0]), name='Fit')\nfig.add_scatter(x=sample['Wavelength'], y=np.zeros(sample.shape[0]), name='Residual')\n\nfig.update_xaxes(title_text='Wavelength (nm)')\nfig.update_yaxes(title_text='I (a.u.)')\n\n\n# Create some widgets to interact with and show the output\nlook = {'sizing_mode': 'stretch_width'}\n\nwids = {p:pnw.FloatSlider(name = p, start=params[p].min, end=params[p].max, value=params[p].value, step=0.01,**look) for p in params if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']}\nwids_result = {p:pnw.FloatInput(name = p,**look) for p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']}\nbtn_fit = pnw.Button(name='Fit',button_type='primary', **look)\nselect_file = pnw.Select(name='Select file', options = fs, **look)\n\n\n\n# Create and register callbacks to actually respond and do stuff\ndef update_simulation(event):\n    \"\"\"Callback to update the preview for finetuning the initial guess\"\"\"\n    params[event.obj.name].value=event.new\n    with fig.batch_update():\n        ynew = model.eval(x=fig.data[0].x, **{n:w.value for n,w in wids.items()})\n        fig.data[1].x = fig.data[0].x\n        fig.data[1].y = ynew\n\ndef fit_iter_cb(pars, iteration, resid,*args, **kwargs):\n    \"\"\"Callback to update on fit iterations, so we can see the progress\"\"\"\n    if iteration % 10 ==0:\n        with fig.batch_update():\n            ynew = model.eval(x=fig.data[0].x, **pars)\n            fig.data[2].x =fig.data[0].x\n            fig.data[2].y = ynew\n            fig.data[3].x = fig.data[0].x\n            fig.data[3].y = resid\n            for p in pars:\n                if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']:\n                    wids_result[p].value = pars[p].value\n    else:\n        pass\n\ndef cb_fit(*args):\n    \"\"\"Callback to start the fitting routine.\n    Upon completion it makes the button green, to show the fit completed.\n    The fitted parameters are updated in `params` upon completion\"\"\"\n    btn_fit.button_type='danger'\n    result = model.fit(fig.data[0].y, x=fig.data[0].x, params=params, iter_cb= fit_iter_cb, max_nfev=300)\n    btn_fit.button_type='success'\n    fit_iter_cb(result.params, 10, result.residual)\n    for p in  result.params:\n        params[p].value=result.params[p].value\n\ndef read_file(*args):\n    df = pd.read_csv(select_file.value, sep='\\t', header=1, names=['Wavelength', 'I'])\n    df['Norm'] = (df['I']-df['I'].min())/(df['I'].max()-df['I'].min())\n    with fig.batch_update():\n        fig.data[0].x = df['Wavelength'].to_numpy()\n        fig.data[0].y = df['Norm'].to_numpy()\n\nfor n,w in wids.items():\n    w.param.watch(update_simulation,'value_throttled')\nbtn_fit.on_click(cb_fit)\nselect_file.param.watch(read_file, 'value')\n\nlayout = pn.Column(pn.pane.Plotly(fig,**look),pn.Row(*wids.values()), pn.Row(btn_fit, select_file), pn.Row(*wids_result.values(), **look), height=650,**look)\ndisplay(layout)\n</pre> # Set up the plot # fig = go.FigureWidget() fig = go.Figure() fig.add_scatter(x=sample['Wavelength'], y=sample['Norm'], name='Measured') fig.add_scatter(x=sample['Wavelength'], y=model.eval(x=sample['Wavelength'].values, params=params), name='Simulation', line_dash='dash') fig.add_scatter(x=sample['Wavelength'], y=np.zeros(sample.shape[0]), name='Fit') fig.add_scatter(x=sample['Wavelength'], y=np.zeros(sample.shape[0]), name='Residual')  fig.update_xaxes(title_text='Wavelength (nm)') fig.update_yaxes(title_text='I (a.u.)')   # Create some widgets to interact with and show the output look = {'sizing_mode': 'stretch_width'}  wids = {p:pnw.FloatSlider(name = p, start=params[p].min, end=params[p].max, value=params[p].value, step=0.01,**look) for p in params if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']} wids_result = {p:pnw.FloatInput(name = p,**look) for p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']} btn_fit = pnw.Button(name='Fit',button_type='primary', **look) select_file = pnw.Select(name='Select file', options = fs, **look)    # Create and register callbacks to actually respond and do stuff def update_simulation(event):     \"\"\"Callback to update the preview for finetuning the initial guess\"\"\"     params[event.obj.name].value=event.new     with fig.batch_update():         ynew = model.eval(x=fig.data[0].x, **{n:w.value for n,w in wids.items()})         fig.data[1].x = fig.data[0].x         fig.data[1].y = ynew  def fit_iter_cb(pars, iteration, resid,*args, **kwargs):     \"\"\"Callback to update on fit iterations, so we can see the progress\"\"\"     if iteration % 10 ==0:         with fig.batch_update():             ynew = model.eval(x=fig.data[0].x, **pars)             fig.data[2].x =fig.data[0].x             fig.data[2].y = ynew             fig.data[3].x = fig.data[0].x             fig.data[3].y = resid             for p in pars:                 if p in ['mu', 'T_rot', 'T_vib', 'sigma', 'gamma']:                     wids_result[p].value = pars[p].value     else:         pass  def cb_fit(*args):     \"\"\"Callback to start the fitting routine.     Upon completion it makes the button green, to show the fit completed.     The fitted parameters are updated in `params` upon completion\"\"\"     btn_fit.button_type='danger'     result = model.fit(fig.data[0].y, x=fig.data[0].x, params=params, iter_cb= fit_iter_cb, max_nfev=300)     btn_fit.button_type='success'     fit_iter_cb(result.params, 10, result.residual)     for p in  result.params:         params[p].value=result.params[p].value  def read_file(*args):     df = pd.read_csv(select_file.value, sep='\\t', header=1, names=['Wavelength', 'I'])     df['Norm'] = (df['I']-df['I'].min())/(df['I'].max()-df['I'].min())     with fig.batch_update():         fig.data[0].x = df['Wavelength'].to_numpy()         fig.data[0].y = df['Norm'].to_numpy()  for n,w in wids.items():     w.param.watch(update_simulation,'value_throttled') btn_fit.on_click(cb_fit) select_file.param.watch(read_file, 'value')  layout = pn.Column(pn.pane.Plotly(fig,**look),pn.Row(*wids.values()), pn.Row(btn_fit, select_file), pn.Row(*wids_result.values(), **look), height=650,**look) display(layout) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/plotly/#interactive-plotly-plot","title":"Interactive Plotly plot\u00b6","text":"<p>This example demonstrates how to fit emission spectra using <code>Moose</code> and visualize the result with <code>Plotly</code> in interactive mode.</p> <p>The initial guess of the parameters for the fits can be adjusted using the slider widgets in the minimal UI below.</p> <p>Once satisfied with the guess, pressing the <code>Fit</code> button will execute the <code>cb_fit</code> callback.</p> <p>This callback contains the actual call to fit the data.</p> <p>The fit procedure can be performed on either of two included sample files in the folder <code>./N2SPS</code>:</p> <ol> <li><p>A spectrum of the second positive system (0,0) band, as recorded at the start of a nanosecond repetitively pulsed discharge: <code>20220302_s01_sig.cam</code></p> </li> <li><p>A spectrum simulated by SpecAir as part of the unit test from RADIS</p> <ul> <li>See also: the corresponding GitHub page</li> <li>Or the notebook by the RADIS developers that demonstrates using MassiveOES</li> </ul> </li> </ol>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Moose<ul> <li>FitUtil</li> <li>Simulation</li> </ul> </li> </ul>"},{"location":"reference/Moose/","title":"Moose","text":"<p>Moose allows you to simulate thermal diatomic spectra based on line-by-line databases.</p> <p>Simulation contains the core functionality to work with these databases.</p> <p>When you import <code>Moose</code>, it will check if the <code>lmfit</code> package is installed in your environment.</p> <p>If so, it will import some additional functions in the <code>Moose</code> namespace for your convenience.</p> <p>FitUtil contains these additional functions.</p> <p>To see <code>Moose</code> in action, check out the examples</p>"},{"location":"reference/Moose/#Moose.apply_voigt","title":"<code>apply_voigt(sim, sigma, gamma, norm=False)</code>","text":"<p>Applies Voigt broadening to a simulated stick spectrum, optionally normalizing the surface area to 1.</p> <p>To avoid repeated (different) normalisations from being used while fitting, it defaults to False.</p> <p>Parameters:</p> Name Type Description Default <code>sim</code> <code>array</code> <p>A (stick) simulation</p> required <code>sigma</code> <code>float</code> <p>The Gaussian sigma for the voigt</p> required <code>gamma</code> <code>float</code> <p>The Lorentzian gamma (HWHM) for the voigt</p> required <code>norm</code> <code>bool</code> <p>Boolean to toggle normalizing (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array:           A 2D array of the same shape as the input array <code>sim</code>, but convolved with a voigt profile.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def apply_voigt(\n    sim: np.array, sigma: float, gamma: float, norm: bool = False\n) -&gt; np.array:\n    \"\"\"Applies Voigt broadening to a simulated stick spectrum, optionally normalizing the surface area to 1.\n\n    To avoid repeated (different) normalisations from being used while fitting, it defaults to False.\n\n    Arguments:\n        sim (np.array):     A (stick) simulation\n        sigma (float):      The Gaussian sigma for the voigt\n        gamma (float):      The Lorentzian gamma (HWHM) for the voigt\n        norm (bool):        Boolean to toggle normalizing (default: False)\n\n    Returns:\n        np.array:           A 2D array of the same shape as the input array `sim`, but convolved with a voigt profile.\n    \"\"\"\n    x = sim[:, 0]\n    dim = int(len(x))\n    if dim % 2 == 0:\n        mu = (x[int(dim / 2) - 1] + x[int(dim / 2)]) / 2\n    else:\n        mu = x[int(dim / 2)]\n\n    v = vgt(x, sigma, gamma, mu, 1, 0)\n    conv = scipy.signal.fftconvolve(sim[:, 1], v, mode=\"same\")\n    if norm:\n        conv /= scipy.integrate.trapezoid(conv, x)\n\n    return np.array([x, conv]).T\n</code></pre>"},{"location":"reference/Moose/#Moose.create_stick_spectrum","title":"<code>create_stick_spectrum(T_vib, T_rot, df_db=None, kind='Emission', wl_mode='air')</code>","text":"<p>Create a stick spectrum based on the data retrieved from a SQL database with the <code>query_DB</code> function. Alternatively, can be provided with any pandas DataFrame that has the requisite columns for the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>T_vib</code> <code>float</code> <p>Vibrational temperature</p> required <code>T_rot</code> <code>float</code> <p>Rotational temperature</p> required <code>df_db</code> <code>DataFrame</code> <p>A pandas DataFrame containing the database data</p> <code>None</code> <code>kind</code> <code>str</code> <p>Either 'Absorption' or 'Emission' depending on the kind of spectrum to simulate.</p> <code>'Emission'</code> <code>wl_mode</code> <code>str</code> <p>Either 'air' or 'vacuum' depending which equivalent we want for the wavelength.</p> <code>'air'</code> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def create_stick_spectrum(\n    T_vib: float,\n    T_rot: float,\n    df_db: pd.DataFrame = None,\n    kind: Literal[\"Absorption\", \"Emission\"] = \"Emission\",\n    wl_mode: Literal[\"air\", \"vacuum\"] = \"air\",\n):\n    \"\"\"Create a stick spectrum based on the data retrieved from a SQL database with the `query_DB` function.\n    Alternatively, can be provided with any pandas DataFrame that has the requisite columns for the calculation.\n\n    Arguments:\n        T_vib (float):          Vibrational temperature\n        T_rot (float):          Rotational temperature\n        df_db (pd.DataFrame):   A pandas DataFrame containing the database data\n        kind (str):             Either 'Absorption' or 'Emission' depending on the kind of spectrum to simulate.\n        wl_mode (str):          Either 'air' or 'vacuum' depending which equivalent we want for the wavelength.\n    \"\"\"\n\n    if type(df_db) == type(None):\n        raise TypeError(\"No Dataframe with database data supplied as kwarg\")\n    kB = (\n        const.physical_constants[\"Boltzmann constant in inverse meters per kelvin\"][0]\n        / 100\n    )\n    pops = (2 * df_db[\"J\"] + 1) * np.exp(\n        -df_db[\"E_v\"] / (kB * T_vib) - df_db[\"E_J\"] / (kB * T_rot)\n    )\n    pops /= pops.sum()\n    if kind == \"Emission\":\n        y = pops * df_db[\"A\"]\n    elif kind == \"Absorption\":\n        y = pops * df_db[\"B\"]\n    return np.array([df_db[\"{}_wavelength\".format(wl_mode)], y]).T\n</code></pre>"},{"location":"reference/Moose/#Moose.equidistant_mesh","title":"<code>equidistant_mesh(sim, wl_pad=10, resolution=100)</code>","text":"<p>Creates an equidistant mesh from a (stick) simulation, where the mesh resolution per nanometer is controlled by the <code>resolution</code>.</p> <p>The simulated line intensities are rebinned onto the equidistant mesh by summing their values, if multiple lines fall into the same bin.</p> <p>Parameters:</p> Name Type Description Default <code>sim</code> <code>array</code> <p>The 2D numpy array containing a simulation</p> required <code>wl_pad</code> <code>float</code> <p>The padding of the wavelength axis in nm to avoid edge effects</p> <code>10</code> <code>resolution</code> <code>int</code> <p>The resolution at which to construct the equidistant mesh (per nanometer) compared to the simulation (default: 100)</p> <code>100</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.array:           A 2D array containing the mesh grid positions and corresponding stick values.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def equidistant_mesh(\n    sim: np.array, wl_pad: float = 10, resolution: int = 100\n) -&gt; np.ndarray:\n    \"\"\"Creates an equidistant mesh from a (stick) simulation, where the mesh resolution per nanometer is controlled by the `resolution`.\n\n    The simulated line intensities are rebinned onto the equidistant mesh by summing their values, if multiple lines fall into the same bin.\n\n    Arguments:\n        sim (np.array):     The 2D numpy array containing a simulation\n        wl_pad (float):     The padding of the wavelength axis in nm to avoid edge effects\n        resolution (int):   The resolution at which to construct the equidistant mesh (per nanometer) compared to the simulation (default: 100)\n\n    Returns:\n        np.array:           A 2D array containing the mesh grid positions and corresponding stick values.\n    \"\"\"\n    delta = sim[-1, 0] - sim[0, 0] + 2 * wl_pad\n    points = int(delta * resolution)\n    equid = np.linspace(sim[0, 0].min() - wl_pad, sim[:, 0].max() + wl_pad, points)\n    binned, _, _ = binned_statistic(sim[:, 0], sim[:, 1], statistic=\"sum\", bins=equid)\n    wl_grid = (\n        equid[:-1] + (equid[1] - equid[0]) / 2\n    )  # grid at middle points of intervals\n\n    return np.array([wl_grid, binned]).T\n</code></pre>"},{"location":"reference/Moose/#Moose.make_model","title":"<code>make_model(species, range=(0, np.inf), resolution=100, wl_pad=10, **kwargs)</code>","text":"<p>Convenience function to create a <code>lmfit.Model</code> instance already prepared with the line-by-line database for fitting.</p> <p>Parameters:</p> Name Type Description Default <code>species</code> <code>str</code> <p>The name of the species database to query.</p> required <code>range</code> <code>tuple[float, float]</code> <p>The wavelength range in nanometer to restric the database query to. Defaults to (0,np.inf)</p> <code>(0, inf)</code> <code>resolution</code> <code>int</code> <p>The resolution per nanometer of  the equidistant mesh compared to bin/sample simulation by (default: 100)</p> <code>100</code> <code>wl_pad</code> <code>float</code> <p>The amount of nanometer to pad the x-axis of the simulation with to avoid edge effects. Default: 10</p> <code>10</code> <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>A <code>Model</code> object that can be used for fitting</p> <code>params</code> <code>Parameters</code> <p>A <code>Parameters</code> object that can be used for fitting, containing default initial values and ranges.</p> Source code in <code>src/Moose/FitUtil.py</code> <pre><code>def make_model(\n    species: str,\n    range: tuple[float, float] = (0, np.inf),\n    resolution: int = 100,\n    wl_pad: float = 10,\n    **kwargs,\n):\n    \"\"\"Convenience function to create a `lmfit.Model` instance already prepared with the line-by-line database for fitting.\n\n    Args:\n        species (str): The name of the species database to query.\n        range (tuple[float,float]): The wavelength range in nanometer to restric the database query to. Defaults to (0,np.inf)\n        resolution (int):   The resolution per nanometer of  the equidistant mesh compared to bin/sample simulation by (default: 100)\n        wl_pad (float): The amount of nanometer to pad the x-axis of the simulation with to avoid edge effects. Default: 10\n\n    Returns:\n        model (lmfit.Model): A `Model` object that can be used for fitting\n        params (lmfit.Parameters): A `Parameters` object that can be used for fitting, containing default initial values and ranges.\n    \"\"\"\n    pars = kwargs.pop(\"params\", default_params)\n    db = query_DB(species, range, **kwargs)\n    # param_names = kwargs.pop('param_names', [p for p in _default_params.keys()]) # Makes it possible to change what are considered fit parameters. Be default only `wl_pad` and `resolution` are excluded\n    model = lmfit.Model(model_for_fit, sim_db=db)\n    params = lmfit.create_params(**pars)\n    params[\"wl_pad\"].value = wl_pad\n    params[\"resolution\"].value = resolution\n    return model, params\n</code></pre>"},{"location":"reference/Moose/#Moose.match_spectra","title":"<code>match_spectra(meas, sim)</code>","text":"<p>Matches a simulation to the same x-axis as the measurement using interpolation.</p> <p>Make sure the simulation spans a larger range, fully containing the experimental range.</p> <p>Effectively downsamples the simulation to the measurement x data points, interpolating the y values, for residual minimization</p> <p>Parameters:</p> Name Type Description Default <code>meas</code> <code>np.array)   </code> <p>A 2D array containing a single measurement of emission as function of wavelength</p> required <code>sim</code> <code> (np.array)   </code> <p>A 2D array containing a simulated spectrum.</p> required <p>Returns:</p> Type Description <p>np.array          :   A 2D array of the simulation, evaluated at the same grid coordinates as the measurement.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def match_spectra(meas: np.array, sim: np.array):\n    \"\"\"Matches a simulation to the same x-axis as the measurement using interpolation.\n\n    Make sure the simulation spans a larger range, fully containing the experimental range.\n\n    Effectively downsamples the simulation to the measurement x data points, interpolating the y values, for residual minimization\n\n    Arguments:\n        meas (np.array)   :   A 2D array containing a single measurement of emission as function of wavelength\n        sim  (np.array)   :   A 2D array containing a simulated spectrum.\n\n    Returns:\n        np.array          :   A 2D array of the simulation, evaluated at the same grid coordinates as the measurement.\n    \"\"\"\n\n    interp = scipy.interpolate.interp1d(sim[:, 0], sim[:, 1])\n    try:\n        matched_y = interp(meas[:, 0])\n    except ValueError as e:\n        raise ValueError(\n            f\"Wavelength outside of interpolation range, try setting a larger value for `wl_pad` kwarg:\\n{e.args}\"\n        )\n    return np.array([meas[:, 0], matched_y]).T\n</code></pre>"},{"location":"reference/Moose/#Moose.model_for_fit","title":"<code>model_for_fit(x, sigma, gamma, mu, T_rot, T_vib, A=1, b=0, resolution=100, wl_pad=10, sim_db=None, **kwargs)</code>","text":"<p>Model function with function signature compatible for usage with lmfit.Model.</p> <p>Creates and broadens an equidistant stick spectrum from the provided simulation database.</p> <p>After broadening, resamples the simulation to the same coordinates as the (measured) data.</p> <p>Returns a spectrum normalized on the interval [b,A+b].</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>The x-axis of the (measured) data that we want to compare/fit against</p> required <code>sigma</code> <code>float</code> <p>Gaussian broadening width of Voigt</p> required <code>gamma</code> <code>float</code> <p>Lorentzian broadening width of Voigt</p> required <code>mu</code> <code>float</code> <p>The shift in x-coordinates between data and simulation, negative shift is towards longer wavelength</p> required <code>T_rot</code> <code>float</code> <p>The rotational temperature in Kelvin</p> required <code>T_vib</code> <code>float</code> <p>The vibrational temperature in Kelvin</p> required <code>A</code> <code>float</code> <p>The amplitude scaling factor of the spectrum (default: 1)</p> <code>1</code> <code>b</code> <code>float</code> <p>The offset w.r.t. 0 of the spectrum (default: 0)</p> <code>0</code> <code>sim_db</code> <code>DataFrame</code> <p>The DataFrame containing the database used for the simulation.</p> <code>None</code> <code>wl_pad</code> <code>float</code> <p>The amount of nanometer to pad the x-axis of the simulation with to avoid edge effects. Default: 10</p> <code>10</code> <code>resolution</code> <code>int</code> <p>The resolution per nanometer of  the equidistant mesh compared to bin/sample simulation by (default: 100)</p> <code>100</code> <code>mode</code> <code>str</code> <p>The mode of the spectrum, i.e. 'Emission' versus 'Absorption' (default: Emission)</p> required <code>wl_mode</code> <code>str</code> <p>Whether to use 'air' vs 'vacuum' wavelength (default: air)</p> required <p>Returns:</p> Type Description <p>np.array:       A 1D vector representing the signal intensity calculated from the simulation, which can be used for the minimisation procedure.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def model_for_fit(\n    x: np.array,\n    sigma: float,\n    gamma: float,\n    mu: float,\n    T_rot: float,\n    T_vib: float,\n    A: float = 1,\n    b: float = 0,\n    resolution: int = 100,\n    wl_pad: float = 10,\n    sim_db: pd.DataFrame = None,\n    **kwargs,\n):\n    \"\"\"Model function with function signature compatible for usage with [lmfit](https://lmfit.github.io/lmfit-py/).Model.\n\n    Creates and broadens an equidistant stick spectrum from the provided simulation database.\n\n    After broadening, resamples the simulation to the same coordinates as the (measured) data.\n\n    Returns a spectrum normalized on the interval [b,A+b].\n\n    Arguments:\n        x (np.array):               The x-axis of the (measured) data that we want to compare/fit against\n        sigma (float):              Gaussian broadening width of Voigt\n        gamma (float):              Lorentzian broadening width of Voigt\n        mu (float):                 The shift in x-coordinates between data and simulation, negative shift is towards longer wavelength\n        T_rot (float):              The rotational temperature in Kelvin\n        T_vib (float):              The vibrational temperature in Kelvin\n        A (float):                  The amplitude scaling factor of the spectrum (default: 1)\n        b (float):                  The offset w.r.t. 0 of the spectrum (default: 0)\n        sim_db (DataFrame):         The DataFrame containing the database used for the simulation.\n        wl_pad (float):             The amount of nanometer to pad the x-axis of the simulation with to avoid edge effects. Default: 10\n        resolution (int):           The resolution per nanometer of  the equidistant mesh compared to bin/sample simulation by (default: 100)\n        mode (str, optional):       The mode of the spectrum, i.e. 'Emission' versus 'Absorption' (default: Emission)\n        wl_mode (str, optional):    Whether to use 'air' vs 'vacuum' wavelength (default: air)\n\n    Returns:\n        np.array:       A 1D vector representing the signal intensity calculated from the simulation, which can be used for the minimisation procedure.\n    \"\"\"\n    sticks = create_stick_spectrum(\n        T_vib,\n        T_rot,\n        sim_db,\n        kind=kwargs.pop(\"mode\", \"Emission\"),\n        wl_mode=kwargs.pop(\"wl_mode\", \"air\"),\n    )\n    refined = equidistant_mesh(sticks, wl_pad=wl_pad, resolution=resolution)\n    simulation = apply_voigt(refined, sigma, gamma)\n    sim_matched = match_spectra((x - mu).reshape(-1, 1), simulation)\n\n    # normalize to [0,1] rather than integral=1\n    val = sim_matched[:, 1]\n    sim_matched[:, 1] = (val - val.min()) / (val.max() - val.min())\n\n    return A * sim_matched[:, 1] + b\n</code></pre>"},{"location":"reference/Moose/#Moose.query_DB","title":"<code>query_DB(db_name, wl=(0, np.inf), kind='emission', mode='air', v_max=None, J_max=None, path=pkg.resource_filename('Moose', 'data'))</code>","text":"<p>Queries a SQL database that must contain line-by-line information, compatible with the format used by MassiveOES.</p> <p>Parameters:</p> Name Type Description Default <code>db_name</code> <code>str</code> <p>The name of the database file to query.</p> required <code>wl</code> <code>tuple</code> <p>A wavelength range to constrain the query to. Defaults to (0,np.inf).</p> <code>(0, inf)</code> <code>kind</code> <code>str</code> <p>The <code>kind</code> of spectrum that you want to create, either <code>emission</code> or <code>absorption</code>. The latter is not really tested. Defaults to 'emission'.</p> <code>'emission'</code> <code>mode</code> <code>str</code> <p>A selection of the <code>mode</code> for wavelength, either in air or vacuum equivalent. Defaults to 'air'.</p> <code>'air'</code> <code>v_max</code> <code>_type_</code> <p>Maximum vibrational quantum number <code>v</code> for the query. Defaults to None.</p> <code>None</code> <code>J_max</code> <code>_type_</code> <p>Maximum rotational quantum number <code>J</code> for the query. Defaults to None.</p> <code>None</code> <code>path</code> <code>str</code> <p>The path to the folder containing database files. Defaults to the location of pre-packed databases.</p> <code>resource_filename('Moose', 'data')</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If there is no database file with name <code>db_name</code> found in the location <code>path</code>.</p> <code>DatabaseError</code> <p>If the SQL query failed, due to incompatible database format, or errors in input</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A pandas DataFrame object containing the result of the query.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def query_DB(\n    db_name: str,\n    wl: tuple = (0, np.inf),\n    kind: str = \"emission\",\n    mode: Literal[\"air\", \"vacuum\"] = \"air\",\n    v_max=None,\n    J_max=None,\n    path: str = pkg.resource_filename(\"Moose\", \"data\"),\n) -&gt; pd.DataFrame:\n    \"\"\"Queries a SQL database that must contain line-by-line information, compatible with the format used by [MassiveOES](https://bitbucket.org/OES_muni/massiveoes).\n\n    Args:\n        db_name (str): The name of the database file to query.\n        wl (tuple, optional): A wavelength range to constrain the query to. Defaults to (0,np.inf).\n        kind (str, optional): The `kind` of spectrum that you want to create, either `emission` or `absorption`. The latter is not really tested. Defaults to 'emission'.\n        mode (str, optional): A selection of the `mode` for wavelength, either in air or vacuum equivalent. Defaults to 'air'.\n        v_max (_type_, optional): Maximum vibrational quantum number `v` for the query. Defaults to None.\n        J_max (_type_, optional): Maximum rotational quantum number `J` for the query. Defaults to None.\n        path (str, optional): The path to the folder containing database files. Defaults to the location of pre-packed databases.\n\n    Raises:\n        FileNotFoundError: If there is no database file with name `db_name` found in the location `path`.\n        sql.DatabaseError: If the SQL query failed, due to incompatible database format, or errors in input\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame object containing the result of the query.\n    \"\"\"\n    if \".db\" not in db_name:\n        db_name += \".db\"\n    wl_min, wl_max = wl\n    db_path = pathlib.Path(path).joinpath(db_name)\n    if not db_path.exists():\n        raise FileNotFoundError(\n            'No such database, the file \"{}\" was not found...'.format(db_path)\n        )\n    with db_path.open(\"rb\") as f:\n        header = f.read(100)\n    if header[:16] != b\"SQLite format 3\\x00\":\n        raise sql.DatabaseError(\"File does not contain a valid SQL3 database...\")\n    else:\n        conn = sql.connect(db_path)\n\n    if kind == \"emission\":\n        q_kind = \"A\"\n        q_join = \"upper_states on upper_state=upper_states.id\"\n    elif kind == \"absorption\":\n        q_kind = \"B\"\n        q_join = \"lower_states on lower_state=lower_states.id\"\n\n    q_j = \"\" if not J_max else f\" and J &lt;= {J_max}\"\n    q_v = \"\" if not v_max else f\" and v &lt;= {v_max}\"\n\n    q_mode = \"{}_wavelength\".format(mode)  # vacuum vs air wavelength equivalent\n\n    if wl_min != 0 and wl_max != np.inf:\n        q_wl = f\" where lines.{q_mode} between {wl_min} and {wl_max}{q_j}{q_v}\"\n    else:\n        q_wl = \"\"\n\n    query = f\"SELECT lines.id, {q_kind}, upper_state, branch, vacuum_wavelength, air_wavelength, wavenumber, lower_state, E_J, J, component, E_v, v from lines inner join {q_join}{q_wl} ORDER BY {q_mode}\"\n    df = pd.read_sql_query(query, conn)\n    conn.close()\n\n    return df\n</code></pre>"},{"location":"reference/Moose/#Moose.set_param","title":"<code>set_param(params, param_name, value=0, min=-np.inf, max=np.inf, vary=True)</code>","text":"<p>Function to set/modify a single parameter in <code>lmfit.Parameters</code> object</p> Source code in <code>src/Moose/FitUtil.py</code> <pre><code>def set_param(\n    params: lmfit.Parameters,\n    param_name: str,\n    value: float = 0,\n    min: float = -np.inf,\n    max: float = np.inf,\n    vary: bool = True,\n):\n    \"\"\"Function to set/modify a single parameter in `lmfit.Parameters` object\"\"\"\n    params[param_name].set(value=value, min=min, max=max, vary=vary)\n</code></pre>"},{"location":"reference/Moose/#Moose.set_params","title":"<code>set_params(params, param_dict=default_params, print=False)</code>","text":"<p>Function to set/modify a bunch of parameters using a dict in a <code>lmfit.Parameters</code> object.</p> Source code in <code>src/Moose/FitUtil.py</code> <pre><code>def set_params(\n    params: lmfit.Parameters, param_dict: dict = default_params, print: bool = False\n):\n    \"\"\"Function to set/modify a bunch of parameters using a dict in a `lmfit.Parameters` object.\"\"\"\n    for param in param_dict:\n        set_param(params, param, **param_dict[param])\n    if print:\n        params.pretty_print()\n</code></pre>"},{"location":"reference/Moose/#Moose.vgt","title":"<code>vgt(x, sigma, gamma, mu, a, b)</code>","text":"<p>Voigt profile implementation, thinly wraps the scipy implementation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>the x-axis array for the voigt profile.</p> required <code>sigma</code> <code>float</code> <p>Gaussian broadening parameter, the standard deviation</p> required <code>gamma</code> <code>float</code> <p>Lorentzian broadening parameter, half width at half maximum</p> required <code>mu</code> <code>float</code> <p>Shift parameter with respect to the center of the x-axis, in the same units as <code>x</code>.</p> required <code>a</code> <code>float</code> <p>Amplitude scaling factor</p> required <code>b</code> <code>float</code> <p>Offset with respect to 0 of the values.</p> required <p>Returns:</p> Type Description <code>array</code> <p>np.array: Voigt profile as a function of <code>x</code></p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def vgt(\n    x: np.array, sigma: float, gamma: float, mu: float, a: float, b: float\n) -&gt; np.array:\n    \"\"\"Voigt profile implementation, thinly wraps the scipy implementation.\n\n    Args:\n        x (np.array): the x-axis array for the voigt profile.\n        sigma (float): Gaussian broadening parameter, the standard deviation\n        gamma (float): Lorentzian broadening parameter, half width at half maximum\n        mu (float): Shift parameter with respect to the center of the x-axis, in the same units as `x`.\n        a (float): Amplitude scaling factor\n        b (float): Offset with respect to 0 of the values.\n\n    Returns:\n        np.array: Voigt profile as a function of `x`\n    \"\"\"\n    return a * voigt_profile(x - mu, sigma, gamma) + b\n</code></pre>"},{"location":"reference/Moose/FitUtil/","title":"FitUtil","text":"<p>Contains convenience functions, to streamline the workflow a bit when using <code>lmfit</code> as a fitting library.</p> <p>Whenever <code>lmfit</code> is installed in the currently active environment, these functions are imported into the <code>Moose</code> namespace as well.</p> <p>This behaviour occurs regardless of if <code>Moose</code> has been installed with the [fit] optional dependencies or not.</p>"},{"location":"reference/Moose/FitUtil/#Moose.FitUtil.make_model","title":"<code>make_model(species, range=(0, np.inf), resolution=100, wl_pad=10, **kwargs)</code>","text":"<p>Convenience function to create a <code>lmfit.Model</code> instance already prepared with the line-by-line database for fitting.</p> <p>Parameters:</p> Name Type Description Default <code>species</code> <code>str</code> <p>The name of the species database to query.</p> required <code>range</code> <code>tuple[float, float]</code> <p>The wavelength range in nanometer to restric the database query to. Defaults to (0,np.inf)</p> <code>(0, inf)</code> <code>resolution</code> <code>int</code> <p>The resolution per nanometer of  the equidistant mesh compared to bin/sample simulation by (default: 100)</p> <code>100</code> <code>wl_pad</code> <code>float</code> <p>The amount of nanometer to pad the x-axis of the simulation with to avoid edge effects. Default: 10</p> <code>10</code> <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>A <code>Model</code> object that can be used for fitting</p> <code>params</code> <code>Parameters</code> <p>A <code>Parameters</code> object that can be used for fitting, containing default initial values and ranges.</p> Source code in <code>src/Moose/FitUtil.py</code> <pre><code>def make_model(\n    species: str,\n    range: tuple[float, float] = (0, np.inf),\n    resolution: int = 100,\n    wl_pad: float = 10,\n    **kwargs,\n):\n    \"\"\"Convenience function to create a `lmfit.Model` instance already prepared with the line-by-line database for fitting.\n\n    Args:\n        species (str): The name of the species database to query.\n        range (tuple[float,float]): The wavelength range in nanometer to restric the database query to. Defaults to (0,np.inf)\n        resolution (int):   The resolution per nanometer of  the equidistant mesh compared to bin/sample simulation by (default: 100)\n        wl_pad (float): The amount of nanometer to pad the x-axis of the simulation with to avoid edge effects. Default: 10\n\n    Returns:\n        model (lmfit.Model): A `Model` object that can be used for fitting\n        params (lmfit.Parameters): A `Parameters` object that can be used for fitting, containing default initial values and ranges.\n    \"\"\"\n    pars = kwargs.pop(\"params\", default_params)\n    db = query_DB(species, range, **kwargs)\n    # param_names = kwargs.pop('param_names', [p for p in _default_params.keys()]) # Makes it possible to change what are considered fit parameters. Be default only `wl_pad` and `resolution` are excluded\n    model = lmfit.Model(model_for_fit, sim_db=db)\n    params = lmfit.create_params(**pars)\n    params[\"wl_pad\"].value = wl_pad\n    params[\"resolution\"].value = resolution\n    return model, params\n</code></pre>"},{"location":"reference/Moose/FitUtil/#Moose.FitUtil.set_param","title":"<code>set_param(params, param_name, value=0, min=-np.inf, max=np.inf, vary=True)</code>","text":"<p>Function to set/modify a single parameter in <code>lmfit.Parameters</code> object</p> Source code in <code>src/Moose/FitUtil.py</code> <pre><code>def set_param(\n    params: lmfit.Parameters,\n    param_name: str,\n    value: float = 0,\n    min: float = -np.inf,\n    max: float = np.inf,\n    vary: bool = True,\n):\n    \"\"\"Function to set/modify a single parameter in `lmfit.Parameters` object\"\"\"\n    params[param_name].set(value=value, min=min, max=max, vary=vary)\n</code></pre>"},{"location":"reference/Moose/FitUtil/#Moose.FitUtil.set_params","title":"<code>set_params(params, param_dict=default_params, print=False)</code>","text":"<p>Function to set/modify a bunch of parameters using a dict in a <code>lmfit.Parameters</code> object.</p> Source code in <code>src/Moose/FitUtil.py</code> <pre><code>def set_params(\n    params: lmfit.Parameters, param_dict: dict = default_params, print: bool = False\n):\n    \"\"\"Function to set/modify a bunch of parameters using a dict in a `lmfit.Parameters` object.\"\"\"\n    for param in param_dict:\n        set_param(params, param, **param_dict[param])\n    if print:\n        params.pretty_print()\n</code></pre>"},{"location":"reference/Moose/Simulation/","title":"Simulation","text":"<p>Provides functionality to simulate and fit spectra, akin to MassiveOES.</p> <p>However (for now) it focusses on multiprocessing support and not introducing unnecessary package or package version dependencies.</p> <p>Inspired by MassiveOES and uses the underlying database files, compiled by J. Vorac and P. Synek.</p>"},{"location":"reference/Moose/Simulation/#Moose.Simulation.apply_voigt","title":"<code>apply_voigt(sim, sigma, gamma, norm=False)</code>","text":"<p>Applies Voigt broadening to a simulated stick spectrum, optionally normalizing the surface area to 1.</p> <p>To avoid repeated (different) normalisations from being used while fitting, it defaults to False.</p> <p>Parameters:</p> Name Type Description Default <code>sim</code> <code>array</code> <p>A (stick) simulation</p> required <code>sigma</code> <code>float</code> <p>The Gaussian sigma for the voigt</p> required <code>gamma</code> <code>float</code> <p>The Lorentzian gamma (HWHM) for the voigt</p> required <code>norm</code> <code>bool</code> <p>Boolean to toggle normalizing (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array:           A 2D array of the same shape as the input array <code>sim</code>, but convolved with a voigt profile.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def apply_voigt(\n    sim: np.array, sigma: float, gamma: float, norm: bool = False\n) -&gt; np.array:\n    \"\"\"Applies Voigt broadening to a simulated stick spectrum, optionally normalizing the surface area to 1.\n\n    To avoid repeated (different) normalisations from being used while fitting, it defaults to False.\n\n    Arguments:\n        sim (np.array):     A (stick) simulation\n        sigma (float):      The Gaussian sigma for the voigt\n        gamma (float):      The Lorentzian gamma (HWHM) for the voigt\n        norm (bool):        Boolean to toggle normalizing (default: False)\n\n    Returns:\n        np.array:           A 2D array of the same shape as the input array `sim`, but convolved with a voigt profile.\n    \"\"\"\n    x = sim[:, 0]\n    dim = int(len(x))\n    if dim % 2 == 0:\n        mu = (x[int(dim / 2) - 1] + x[int(dim / 2)]) / 2\n    else:\n        mu = x[int(dim / 2)]\n\n    v = vgt(x, sigma, gamma, mu, 1, 0)\n    conv = scipy.signal.fftconvolve(sim[:, 1], v, mode=\"same\")\n    if norm:\n        conv /= scipy.integrate.trapezoid(conv, x)\n\n    return np.array([x, conv]).T\n</code></pre>"},{"location":"reference/Moose/Simulation/#Moose.Simulation.create_stick_spectrum","title":"<code>create_stick_spectrum(T_vib, T_rot, df_db=None, kind='Emission', wl_mode='air')</code>","text":"<p>Create a stick spectrum based on the data retrieved from a SQL database with the <code>query_DB</code> function. Alternatively, can be provided with any pandas DataFrame that has the requisite columns for the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>T_vib</code> <code>float</code> <p>Vibrational temperature</p> required <code>T_rot</code> <code>float</code> <p>Rotational temperature</p> required <code>df_db</code> <code>DataFrame</code> <p>A pandas DataFrame containing the database data</p> <code>None</code> <code>kind</code> <code>str</code> <p>Either 'Absorption' or 'Emission' depending on the kind of spectrum to simulate.</p> <code>'Emission'</code> <code>wl_mode</code> <code>str</code> <p>Either 'air' or 'vacuum' depending which equivalent we want for the wavelength.</p> <code>'air'</code> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def create_stick_spectrum(\n    T_vib: float,\n    T_rot: float,\n    df_db: pd.DataFrame = None,\n    kind: Literal[\"Absorption\", \"Emission\"] = \"Emission\",\n    wl_mode: Literal[\"air\", \"vacuum\"] = \"air\",\n):\n    \"\"\"Create a stick spectrum based on the data retrieved from a SQL database with the `query_DB` function.\n    Alternatively, can be provided with any pandas DataFrame that has the requisite columns for the calculation.\n\n    Arguments:\n        T_vib (float):          Vibrational temperature\n        T_rot (float):          Rotational temperature\n        df_db (pd.DataFrame):   A pandas DataFrame containing the database data\n        kind (str):             Either 'Absorption' or 'Emission' depending on the kind of spectrum to simulate.\n        wl_mode (str):          Either 'air' or 'vacuum' depending which equivalent we want for the wavelength.\n    \"\"\"\n\n    if type(df_db) == type(None):\n        raise TypeError(\"No Dataframe with database data supplied as kwarg\")\n    kB = (\n        const.physical_constants[\"Boltzmann constant in inverse meters per kelvin\"][0]\n        / 100\n    )\n    pops = (2 * df_db[\"J\"] + 1) * np.exp(\n        -df_db[\"E_v\"] / (kB * T_vib) - df_db[\"E_J\"] / (kB * T_rot)\n    )\n    pops /= pops.sum()\n    if kind == \"Emission\":\n        y = pops * df_db[\"A\"]\n    elif kind == \"Absorption\":\n        y = pops * df_db[\"B\"]\n    return np.array([df_db[\"{}_wavelength\".format(wl_mode)], y]).T\n</code></pre>"},{"location":"reference/Moose/Simulation/#Moose.Simulation.equidistant_mesh","title":"<code>equidistant_mesh(sim, wl_pad=10, resolution=100)</code>","text":"<p>Creates an equidistant mesh from a (stick) simulation, where the mesh resolution per nanometer is controlled by the <code>resolution</code>.</p> <p>The simulated line intensities are rebinned onto the equidistant mesh by summing their values, if multiple lines fall into the same bin.</p> <p>Parameters:</p> Name Type Description Default <code>sim</code> <code>array</code> <p>The 2D numpy array containing a simulation</p> required <code>wl_pad</code> <code>float</code> <p>The padding of the wavelength axis in nm to avoid edge effects</p> <code>10</code> <code>resolution</code> <code>int</code> <p>The resolution at which to construct the equidistant mesh (per nanometer) compared to the simulation (default: 100)</p> <code>100</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.array:           A 2D array containing the mesh grid positions and corresponding stick values.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def equidistant_mesh(\n    sim: np.array, wl_pad: float = 10, resolution: int = 100\n) -&gt; np.ndarray:\n    \"\"\"Creates an equidistant mesh from a (stick) simulation, where the mesh resolution per nanometer is controlled by the `resolution`.\n\n    The simulated line intensities are rebinned onto the equidistant mesh by summing their values, if multiple lines fall into the same bin.\n\n    Arguments:\n        sim (np.array):     The 2D numpy array containing a simulation\n        wl_pad (float):     The padding of the wavelength axis in nm to avoid edge effects\n        resolution (int):   The resolution at which to construct the equidistant mesh (per nanometer) compared to the simulation (default: 100)\n\n    Returns:\n        np.array:           A 2D array containing the mesh grid positions and corresponding stick values.\n    \"\"\"\n    delta = sim[-1, 0] - sim[0, 0] + 2 * wl_pad\n    points = int(delta * resolution)\n    equid = np.linspace(sim[0, 0].min() - wl_pad, sim[:, 0].max() + wl_pad, points)\n    binned, _, _ = binned_statistic(sim[:, 0], sim[:, 1], statistic=\"sum\", bins=equid)\n    wl_grid = (\n        equid[:-1] + (equid[1] - equid[0]) / 2\n    )  # grid at middle points of intervals\n\n    return np.array([wl_grid, binned]).T\n</code></pre>"},{"location":"reference/Moose/Simulation/#Moose.Simulation.match_spectra","title":"<code>match_spectra(meas, sim)</code>","text":"<p>Matches a simulation to the same x-axis as the measurement using interpolation.</p> <p>Make sure the simulation spans a larger range, fully containing the experimental range.</p> <p>Effectively downsamples the simulation to the measurement x data points, interpolating the y values, for residual minimization</p> <p>Parameters:</p> Name Type Description Default <code>meas</code> <code>np.array)   </code> <p>A 2D array containing a single measurement of emission as function of wavelength</p> required <code>sim</code> <code> (np.array)   </code> <p>A 2D array containing a simulated spectrum.</p> required <p>Returns:</p> Type Description <p>np.array          :   A 2D array of the simulation, evaluated at the same grid coordinates as the measurement.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def match_spectra(meas: np.array, sim: np.array):\n    \"\"\"Matches a simulation to the same x-axis as the measurement using interpolation.\n\n    Make sure the simulation spans a larger range, fully containing the experimental range.\n\n    Effectively downsamples the simulation to the measurement x data points, interpolating the y values, for residual minimization\n\n    Arguments:\n        meas (np.array)   :   A 2D array containing a single measurement of emission as function of wavelength\n        sim  (np.array)   :   A 2D array containing a simulated spectrum.\n\n    Returns:\n        np.array          :   A 2D array of the simulation, evaluated at the same grid coordinates as the measurement.\n    \"\"\"\n\n    interp = scipy.interpolate.interp1d(sim[:, 0], sim[:, 1])\n    try:\n        matched_y = interp(meas[:, 0])\n    except ValueError as e:\n        raise ValueError(\n            f\"Wavelength outside of interpolation range, try setting a larger value for `wl_pad` kwarg:\\n{e.args}\"\n        )\n    return np.array([meas[:, 0], matched_y]).T\n</code></pre>"},{"location":"reference/Moose/Simulation/#Moose.Simulation.model_for_fit","title":"<code>model_for_fit(x, sigma, gamma, mu, T_rot, T_vib, A=1, b=0, resolution=100, wl_pad=10, sim_db=None, **kwargs)</code>","text":"<p>Model function with function signature compatible for usage with lmfit.Model.</p> <p>Creates and broadens an equidistant stick spectrum from the provided simulation database.</p> <p>After broadening, resamples the simulation to the same coordinates as the (measured) data.</p> <p>Returns a spectrum normalized on the interval [b,A+b].</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>The x-axis of the (measured) data that we want to compare/fit against</p> required <code>sigma</code> <code>float</code> <p>Gaussian broadening width of Voigt</p> required <code>gamma</code> <code>float</code> <p>Lorentzian broadening width of Voigt</p> required <code>mu</code> <code>float</code> <p>The shift in x-coordinates between data and simulation, negative shift is towards longer wavelength</p> required <code>T_rot</code> <code>float</code> <p>The rotational temperature in Kelvin</p> required <code>T_vib</code> <code>float</code> <p>The vibrational temperature in Kelvin</p> required <code>A</code> <code>float</code> <p>The amplitude scaling factor of the spectrum (default: 1)</p> <code>1</code> <code>b</code> <code>float</code> <p>The offset w.r.t. 0 of the spectrum (default: 0)</p> <code>0</code> <code>sim_db</code> <code>DataFrame</code> <p>The DataFrame containing the database used for the simulation.</p> <code>None</code> <code>wl_pad</code> <code>float</code> <p>The amount of nanometer to pad the x-axis of the simulation with to avoid edge effects. Default: 10</p> <code>10</code> <code>resolution</code> <code>int</code> <p>The resolution per nanometer of  the equidistant mesh compared to bin/sample simulation by (default: 100)</p> <code>100</code> <code>mode</code> <code>str</code> <p>The mode of the spectrum, i.e. 'Emission' versus 'Absorption' (default: Emission)</p> required <code>wl_mode</code> <code>str</code> <p>Whether to use 'air' vs 'vacuum' wavelength (default: air)</p> required <p>Returns:</p> Type Description <p>np.array:       A 1D vector representing the signal intensity calculated from the simulation, which can be used for the minimisation procedure.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def model_for_fit(\n    x: np.array,\n    sigma: float,\n    gamma: float,\n    mu: float,\n    T_rot: float,\n    T_vib: float,\n    A: float = 1,\n    b: float = 0,\n    resolution: int = 100,\n    wl_pad: float = 10,\n    sim_db: pd.DataFrame = None,\n    **kwargs,\n):\n    \"\"\"Model function with function signature compatible for usage with [lmfit](https://lmfit.github.io/lmfit-py/).Model.\n\n    Creates and broadens an equidistant stick spectrum from the provided simulation database.\n\n    After broadening, resamples the simulation to the same coordinates as the (measured) data.\n\n    Returns a spectrum normalized on the interval [b,A+b].\n\n    Arguments:\n        x (np.array):               The x-axis of the (measured) data that we want to compare/fit against\n        sigma (float):              Gaussian broadening width of Voigt\n        gamma (float):              Lorentzian broadening width of Voigt\n        mu (float):                 The shift in x-coordinates between data and simulation, negative shift is towards longer wavelength\n        T_rot (float):              The rotational temperature in Kelvin\n        T_vib (float):              The vibrational temperature in Kelvin\n        A (float):                  The amplitude scaling factor of the spectrum (default: 1)\n        b (float):                  The offset w.r.t. 0 of the spectrum (default: 0)\n        sim_db (DataFrame):         The DataFrame containing the database used for the simulation.\n        wl_pad (float):             The amount of nanometer to pad the x-axis of the simulation with to avoid edge effects. Default: 10\n        resolution (int):           The resolution per nanometer of  the equidistant mesh compared to bin/sample simulation by (default: 100)\n        mode (str, optional):       The mode of the spectrum, i.e. 'Emission' versus 'Absorption' (default: Emission)\n        wl_mode (str, optional):    Whether to use 'air' vs 'vacuum' wavelength (default: air)\n\n    Returns:\n        np.array:       A 1D vector representing the signal intensity calculated from the simulation, which can be used for the minimisation procedure.\n    \"\"\"\n    sticks = create_stick_spectrum(\n        T_vib,\n        T_rot,\n        sim_db,\n        kind=kwargs.pop(\"mode\", \"Emission\"),\n        wl_mode=kwargs.pop(\"wl_mode\", \"air\"),\n    )\n    refined = equidistant_mesh(sticks, wl_pad=wl_pad, resolution=resolution)\n    simulation = apply_voigt(refined, sigma, gamma)\n    sim_matched = match_spectra((x - mu).reshape(-1, 1), simulation)\n\n    # normalize to [0,1] rather than integral=1\n    val = sim_matched[:, 1]\n    sim_matched[:, 1] = (val - val.min()) / (val.max() - val.min())\n\n    return A * sim_matched[:, 1] + b\n</code></pre>"},{"location":"reference/Moose/Simulation/#Moose.Simulation.query_DB","title":"<code>query_DB(db_name, wl=(0, np.inf), kind='emission', mode='air', v_max=None, J_max=None, path=pkg.resource_filename('Moose', 'data'))</code>","text":"<p>Queries a SQL database that must contain line-by-line information, compatible with the format used by MassiveOES.</p> <p>Parameters:</p> Name Type Description Default <code>db_name</code> <code>str</code> <p>The name of the database file to query.</p> required <code>wl</code> <code>tuple</code> <p>A wavelength range to constrain the query to. Defaults to (0,np.inf).</p> <code>(0, inf)</code> <code>kind</code> <code>str</code> <p>The <code>kind</code> of spectrum that you want to create, either <code>emission</code> or <code>absorption</code>. The latter is not really tested. Defaults to 'emission'.</p> <code>'emission'</code> <code>mode</code> <code>str</code> <p>A selection of the <code>mode</code> for wavelength, either in air or vacuum equivalent. Defaults to 'air'.</p> <code>'air'</code> <code>v_max</code> <code>_type_</code> <p>Maximum vibrational quantum number <code>v</code> for the query. Defaults to None.</p> <code>None</code> <code>J_max</code> <code>_type_</code> <p>Maximum rotational quantum number <code>J</code> for the query. Defaults to None.</p> <code>None</code> <code>path</code> <code>str</code> <p>The path to the folder containing database files. Defaults to the location of pre-packed databases.</p> <code>resource_filename('Moose', 'data')</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If there is no database file with name <code>db_name</code> found in the location <code>path</code>.</p> <code>DatabaseError</code> <p>If the SQL query failed, due to incompatible database format, or errors in input</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A pandas DataFrame object containing the result of the query.</p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def query_DB(\n    db_name: str,\n    wl: tuple = (0, np.inf),\n    kind: str = \"emission\",\n    mode: Literal[\"air\", \"vacuum\"] = \"air\",\n    v_max=None,\n    J_max=None,\n    path: str = pkg.resource_filename(\"Moose\", \"data\"),\n) -&gt; pd.DataFrame:\n    \"\"\"Queries a SQL database that must contain line-by-line information, compatible with the format used by [MassiveOES](https://bitbucket.org/OES_muni/massiveoes).\n\n    Args:\n        db_name (str): The name of the database file to query.\n        wl (tuple, optional): A wavelength range to constrain the query to. Defaults to (0,np.inf).\n        kind (str, optional): The `kind` of spectrum that you want to create, either `emission` or `absorption`. The latter is not really tested. Defaults to 'emission'.\n        mode (str, optional): A selection of the `mode` for wavelength, either in air or vacuum equivalent. Defaults to 'air'.\n        v_max (_type_, optional): Maximum vibrational quantum number `v` for the query. Defaults to None.\n        J_max (_type_, optional): Maximum rotational quantum number `J` for the query. Defaults to None.\n        path (str, optional): The path to the folder containing database files. Defaults to the location of pre-packed databases.\n\n    Raises:\n        FileNotFoundError: If there is no database file with name `db_name` found in the location `path`.\n        sql.DatabaseError: If the SQL query failed, due to incompatible database format, or errors in input\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame object containing the result of the query.\n    \"\"\"\n    if \".db\" not in db_name:\n        db_name += \".db\"\n    wl_min, wl_max = wl\n    db_path = pathlib.Path(path).joinpath(db_name)\n    if not db_path.exists():\n        raise FileNotFoundError(\n            'No such database, the file \"{}\" was not found...'.format(db_path)\n        )\n    with db_path.open(\"rb\") as f:\n        header = f.read(100)\n    if header[:16] != b\"SQLite format 3\\x00\":\n        raise sql.DatabaseError(\"File does not contain a valid SQL3 database...\")\n    else:\n        conn = sql.connect(db_path)\n\n    if kind == \"emission\":\n        q_kind = \"A\"\n        q_join = \"upper_states on upper_state=upper_states.id\"\n    elif kind == \"absorption\":\n        q_kind = \"B\"\n        q_join = \"lower_states on lower_state=lower_states.id\"\n\n    q_j = \"\" if not J_max else f\" and J &lt;= {J_max}\"\n    q_v = \"\" if not v_max else f\" and v &lt;= {v_max}\"\n\n    q_mode = \"{}_wavelength\".format(mode)  # vacuum vs air wavelength equivalent\n\n    if wl_min != 0 and wl_max != np.inf:\n        q_wl = f\" where lines.{q_mode} between {wl_min} and {wl_max}{q_j}{q_v}\"\n    else:\n        q_wl = \"\"\n\n    query = f\"SELECT lines.id, {q_kind}, upper_state, branch, vacuum_wavelength, air_wavelength, wavenumber, lower_state, E_J, J, component, E_v, v from lines inner join {q_join}{q_wl} ORDER BY {q_mode}\"\n    df = pd.read_sql_query(query, conn)\n    conn.close()\n\n    return df\n</code></pre>"},{"location":"reference/Moose/Simulation/#Moose.Simulation.vgt","title":"<code>vgt(x, sigma, gamma, mu, a, b)</code>","text":"<p>Voigt profile implementation, thinly wraps the scipy implementation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>the x-axis array for the voigt profile.</p> required <code>sigma</code> <code>float</code> <p>Gaussian broadening parameter, the standard deviation</p> required <code>gamma</code> <code>float</code> <p>Lorentzian broadening parameter, half width at half maximum</p> required <code>mu</code> <code>float</code> <p>Shift parameter with respect to the center of the x-axis, in the same units as <code>x</code>.</p> required <code>a</code> <code>float</code> <p>Amplitude scaling factor</p> required <code>b</code> <code>float</code> <p>Offset with respect to 0 of the values.</p> required <p>Returns:</p> Type Description <code>array</code> <p>np.array: Voigt profile as a function of <code>x</code></p> Source code in <code>src/Moose/Simulation.py</code> <pre><code>def vgt(\n    x: np.array, sigma: float, gamma: float, mu: float, a: float, b: float\n) -&gt; np.array:\n    \"\"\"Voigt profile implementation, thinly wraps the scipy implementation.\n\n    Args:\n        x (np.array): the x-axis array for the voigt profile.\n        sigma (float): Gaussian broadening parameter, the standard deviation\n        gamma (float): Lorentzian broadening parameter, half width at half maximum\n        mu (float): Shift parameter with respect to the center of the x-axis, in the same units as `x`.\n        a (float): Amplitude scaling factor\n        b (float): Offset with respect to 0 of the values.\n\n    Returns:\n        np.array: Voigt profile as a function of `x`\n    \"\"\"\n    return a * voigt_profile(x - mu, sigma, gamma) + b\n</code></pre>"}]}